[
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Token theft] Can an attacker create an order with src_amount = 1 and min_dst_amount = u64::MAX to cause integer overflow in subsequent get_dst_amount() calculations during fill, potentially allowing token theft through underflow? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Validation bypass] The check at line 46 requires src_amount != 0 && min_dst_amount != 0, but does not validate against u64::MAX - can an attacker set these to u64::MAX causing overflow in mul_div operations during fill execution? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Native asset confusion] At lines 51-53, the validation checks if src_mint equals native_mint::id() when src_asset_is_native is false - can an attacker bypass this by providing a fake native mint address that passes equality check but isn't the actual native mint? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Expiration manipulation] The expiration check at line 62 uses Clock::get()?.unix_timestamp < order.expiration_time as i64 - can an attacker set expiration_time to u32::MAX (year 2106) to create a permanent order that locks tokens indefinitely? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Fee manipulation] At line 67, surplus_percentage is validated <= BASE_1E2 (100), but protocol_fee and integrator_fee have no upper bounds - can an attacker set protocol_fee = u16::MAX (65535) causing the entire dst_amount to be consumed by fees, starving the maker? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Estimated amount attack] Line 72 requires estimated_dst_amount >= min_dst_amount, but there's no upper bound check - can an attacker set estimated_dst_amount = u64::MAX to manipulate surplus fee calculations in get_fee_amounts(), extracting excessive protocol fees? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Configuration inconsistency] Lines 77-81 enforce that protocol_dst_acc must be Some() if protocol_fee > 0 OR surplus_percentage > 0 - can an attacker exploit the OR logic by setting surplus_percentage = 0 and protocol_fee = 0 but protocol_dst_acc = Some(), bypassing fee validation in fill()? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Configuration inconsistency] Lines 84-87 check integrator fee config, but what happens if integrator_fee = 0 and integrator_dst_acc = Some()? Can this cause the fill() function to attempt transfers to an unnecessary account, wasting compute units or causing transaction failures? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Cancellation premium exploit] At line 90-93, the validation checks if escrow_src_ata.lamports() >= max_cancellation_premium, but escrow_src_ata is initialized at line 476 (init) - can an attacker exploit the timing by front-running to drain lamports before this check, or manipulate rent-exempt minimums? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Native trait confusion] Line 96 checks order.src_asset_is_native == maker_src_ata.is_none(), but this creates a double-negative logic - can an attacker provide contradictory values that pass this check but fail later operations, causing token lock without ability to cancel? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [SOL wrapping attack] In the native transfer branch at lines 101-108, SOL is transferred to escrow_src_ata and sync_native is called - can an attacker exploit the gap between transfer and sync_native to manipulate the wrapped SOL balance through reentrancy or concurrent transactions? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Token program confusion] Lines 103-108 perform native transfer followed by sync_native - if src_token_program is a malicious token program instead of the official SPL Token program, can it manipulate balances during sync_native to inflate escrow holdings? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [Missing maker_src_ata] At line 122, maker_src_ata.as_ref().ok_or() is used - can an attacker intentionally omit maker_src_ata when src_asset_is_native is false to trigger FusionError::MissingMakerSrcAta after tokens are already transferred, causing order creation to fail but tokens to be locked? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [PDA collision] The escrow PDA is derived at lines 446-457 using order_hash which includes order config - can an attacker craft two different orders that hash to the same value by exploiting hashv() collision vulnerabilities, allowing one order to steal another's escrow? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: create()] [ATA initialization race] escrow_src_ata is initialized with 'init' at line 470 - can an attacker front-run this transaction and pre-initialize the ATA with a different authority, causing the create() to fail after maker's tokens are already approved/transferred? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Expiration bypass] The expiration check at line 135 uses Clock::get()?.unix_timestamp < order.expiration_time - can an attacker manipulate Clock syscall results through validator collusion or exploit timestamp precision to fill expired orders? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Amount validation bypass] Line 140 checks amount <= escrow_src_ata.amount, but doesn't validate amount against order.src_amount - can a resolver fill more than the original order amount by exploiting partial fills from multiple resolvers? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Zero amount DoS] Line 144 checks amount != 0, but what if amount = 1 wei? Can a malicious resolver repeatedly fill orders with amount=1 to grief makers by fragmenting orders and wasting transaction fees? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Order hash collision] Lines 156-163 compute order_hash from order config and accounts - can an attacker provide modified order parameters that hash to an existing order's hash, allowing unauthorized access to someone else's escrow? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [PDA seed manipulation] The escrow PDA validation at lines 176-179 uses maker.key(), order_hash, and bump - can an attacker provide a malicious 'maker' address that when combined with a crafted order_hash produces the same PDA as a legitimate order, enabling escrow theft? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Transfer authority exploit] Lines 166-184 use transfer_checked with escrow as signer - if the src_token_program is a fake token program, can it bypass the authority check and allow unauthorized transfers from escrow? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Arithmetic overflow] At line 186, get_dst_amount() is called with order.src_amount, order.min_dst_amount, amount, and auction data - can an attacker provide extreme values causing mul_div_ceil to overflow, resulting in dst_amount = 0 and free tokens? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Fee calculation exploit] Lines 193-199 call get_fee_amounts() with dst_amount and estimated_dst_amount - can a resolver manipulate timing to fill at a point where actual_dst_amount < estimated_dst_amount, avoiding surplus fees and extracting more value? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Native transfer bypass] Lines 202-208 set up native transfer if dst_asset_is_native is true - can an attacker set dst_asset_is_native = true but provide a dst_mint that isn't native_mint, bypassing token validation and stealing from taker? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Missing taker_dst_ata] At line 215, taker_dst_ata.as_ref().ok_or() can fail - can this be exploited by a resolver to complete the escrow-to-taker transfer but fail on taker-to-maker transfer, stealing escrowed tokens? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Missing maker_dst_ata] Line 222 accesses maker_dst_ata which is init_if_needed at line 573 - can a malicious taker exploit the initialization timing to front-run and set a different authority, redirecting maker's dst tokens? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Uni_transfer reentrancy] Lines 229, 245, 262 call uni_transfer() multiple times - can a malicious token program enable reentrancy during these transfers to re-execute fill() and drain escrow multiple times? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Fee distribution manipulation] Lines 232-246 handle protocol fee transfer by mutating the params variable - can a malicious dst_token_program hook into the transfer to manipulate the amount or destination between iterations? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Inconsistent fee config] Line 241 checks protocol_dst_acc.as_ref().ok_or(InconsistentProtocolFeeConfig) - but what if protocol_fee_amount > 0 but protocol_dst_acc = None due to a race condition? Can this cause tokens to be burned? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Integrator fee bypass] Lines 249-262 transfer integrator fees - can a malicious resolver collude with an integrator to set integrator_fee = u16::MAX and split the fees, draining maker's dst_amount? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Escrow closure timing] Lines 266-280 close escrow if amount equals escrow_src_ata.amount - can a malicious resolver fill with amount = escrow_src_ata.amount - 1, then quickly fill with amount = 1 in a separate transaction to exploit the closure logic? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Lamport leakage] When close_account is called at line 267, lamports go to maker - but what if there are residual lamports from rent or wrapped SOL? Can a resolver front-run the closure to claim these lamports? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Partial fill exploit] The function allows partial fills (amount < escrow balance) - can a resolver repeatedly fill tiny amounts to generate maximum fees while minimizing the actual swap value provided to maker? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Dutch auction manipulation] get_dst_amount() at line 186 uses Dutch auction data - can a resolver wait until the last possible moment before expiration to fill at the most favorable rate, griefing makers? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Access control PDA verification] Lines 511-516 define resolver_access account from whitelist program - is the seeds::program validation sufficient, or can an attacker deploy a fake whitelist program with the same interface to bypass authorization? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Account substitution] The Fill struct at lines 504-595 doesn't explicitly validate that src_mint, dst_mint, maker, maker_receiver match the order hash - can an attacker substitute different accounts to redirect tokens? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Maker receiver validation] maker_receiver is UncheckedAccount at line 523 - can an attacker provide a maker_receiver that differs from the one in order_hash, redirecting dst tokens while still matching the PDA? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Mint mismatch] taker_src_ata constraint at line 562 only checks taker_src_ata.mint.key() == src_mint.key() - can an attacker provide a fake src_mint that passes equality but isn't the actual order's src_mint? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Init_if_needed exploit] maker_dst_ata is init_if_needed at line 573 - can an attacker repeatedly trigger initialization to drain taker's lamports through excessive rent payments? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: fill()] [Token program substitution] dst_token_program and src_token_program are separate - can an attacker provide malicious token programs that appear legitimate but manipulate transfer amounts or authorities? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_dst_amount()] [Integer overflow] Line 771 performs initial_dst_amount.mul_div_ceil(src_amount, initial_src_amount) - can an attacker provide initial_dst_amount = u64::MAX and src_amount = u64::MAX causing mul_div_ceil to overflow and return 0? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_dst_amount()] [Division by zero] If initial_src_amount = 0 in mul_div_ceil at line 771, does the operation panic or return an error? Can an attacker exploit this to DoS order fills? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_dst_amount()] [Rate bump overflow] Lines 776-779 calculate result.mul_div_ceil(BASE_1E5 + rate_bump, BASE_1E5) - if rate_bump is close to u64::MAX - BASE_1E5, can this overflow and wrap around to a tiny value, giving taker free tokens? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_dst_amount()] [Auction data manipulation] Line 776 calls calculate_rate_bump with Clock timestamp - can an attacker manipulate the auction data points to create a rate_bump that causes overflow in the multiplication? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_dst_amount()] [Precision loss] mul_div_ceil rounds up - can an attacker exploit this by repeatedly filling small amounts, each time benefiting from the ceiling rounding to extract more value than intended? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_dst_amount()] [None auction data bypass] When opt_data is None (line 775), rate_bump calculation is skipped - can a resolver intentionally call with opt_data = None to avoid Dutch auction pricing and fill at min_dst_amount? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_dst_amount()] [Timestamp manipulation] Clock::get()?.unix_timestamp at line 776 is used for rate_bump calculation - can a validator collude with a resolver to manipulate the timestamp and get favorable pricing? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_fee_amounts()] [Integrator fee overflow] Line 791 calculates dst_amount.mul_div_floor(integrator_fee as u64, BASE_1E5) - can integrator_fee = u16::MAX cause this to consume the entire dst_amount, leaving nothing for maker? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_fee_amounts()] [Protocol fee overflow] Line 795 calculates protocol_fee_amount with mul_div_floor - can protocol_fee = u16::MAX combined with a large dst_amount overflow the calculation? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_fee_amounts()] [Underflow attack] Line 799 performs (dst_amount - protocol_fee_amount).checked_sub(integrator_fee_amount) - can an attacker set fees such that protocol_fee_amount + integrator_fee_amount > dst_amount, causing an underflow panic? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_fee_amounts()] [Surplus calculation exploit] Lines 803-806 calculate surplus fee only if actual_dst_amount > estimated_dst_amount - can a resolver manipulate timing to ensure actual_dst_amount <= estimated_dst_amount, avoiding surplus fees and keeping more value? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_fee_amounts()] [Surplus percentage overflow] Line 805 performs (actual_dst_amount - estimated_dst_amount).mul_div_floor(surplus_percentage as u64, BASE_1E2) - can extreme values cause overflow? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_fee_amounts()] [Fee sum verification] Line 812 calculates maker_dst_amount = dst_amount - integrator_fee_amount - protocol_fee_amount, but doesn't verify the sum equals dst_amount - can rounding errors accumulate to lose tokens? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_fee_amounts()] [Negative surplus handling] If actual_dst_amount < estimated_dst_amount (unfavorable slippage), protocol_fee_amount is not reduced - can this cause maker to receive less than min_dst_amount after fees? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: get_fee_amounts()] [Zero dst_amount] If dst_amount = 0 due to earlier overflow, all fee calculations return 0 - can this be exploited to drain escrow while paying nothing? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [PDA verification] The escrow PDA is validated at lines 608-614 using only order_hash and maker - can an attacker who knows an order_hash impersonate the maker to cancel their order? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [Native trait bypass] Line 292 checks if src_mint equals native_mint or !order_src_asset_is_native - can an attacker provide a fake order_src_asset_is_native value to bypass this check? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [Native trait double check] Lines 297-299 perform the same native trait check as line 292 - can contradictory values pass one check but fail the other, causing partial cancellation? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [Token transfer before close] Lines 303-326 transfer tokens back to maker before closing escrow - if this transfer fails, does the escrow still get closed at line 329, losing the tokens? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [Missing maker_src_ata exploit] Line 313 requires maker_src_ata for non-native assets - can an attacker intentionally omit this to prevent makers from canceling their orders, locking tokens permanently? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [Wrapped SOL handling] For native assets (line 302 condition false), tokens remain in escrow and only close_account is called - are the wrapped SOL tokens properly unwrapped and returned to maker as native SOL? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [Lamport destination] close_account at line 329 sends lamports to maker - if maker is a PDA without lamport handling, are these lamports lost? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [Order hash manipulation] The order_hash parameter at line 288 is provided by the caller - can a malicious maker provide a different order_hash to cancel someone else's order if they share the same maker address? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [No expiration check] Unlike fill(), cancel() doesn't check if the order is expired - can makers cancel profitable orders after expiration to avoid losses? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel()] [Partial fill cancellation] If the order was partially filled, escrow_src_ata.amount at line 324 reflects remaining tokens - can a maker cancel after a small fill to reclaim most tokens, griefing resolvers? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Premium requirement bypass] Line 351 checks max_cancellation_premium > 0, but what if this value is exactly 1 lamport? Can resolvers still profit from canceling? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Timestamp manipulation] Line 354 gets current_timestamp from Clock - can a validator manipulate this to allow resolvers to cancel orders prematurely? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Expiration check bypass] Line 356 requires current_timestamp >= expiration_time - can an attacker exploit clock precision or timezone differences to cancel before actual expiration? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Order hash recalculation] Lines 364-374 recalculate order_hash - can a malicious resolver provide modified order parameters that still hash to a valid PDA but have different premium calculations? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Token return before premium] Lines 377-402 return tokens to maker before calculating premium - can maker frontrun this to withdraw tokens before resolver claims premium? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Premium calculation exploit] Line 404 calls calculate_premium with current_timestamp - can an attacker exploit the linear interpolation in calculate_premium to game the timing and extract maximum premium? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Reward limit bypass] Line 411 uses std::cmp::min(cancellation_premium, reward_limit) - can a resolver set reward_limit = 0 to cancel orders without paying premium, then claim all lamports? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Lamport calculation underflow] Line 410 calculates maker_amount = escrow_lamports - min(premium, reward_limit) - if premium > escrow_lamports, does this underflow? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Two-step transfer vulnerability] Lines 414-427 close escrow to resolver, then lines 430-435 transfer to maker - can a malicious resolver receive all lamports but fail to forward maker_amount? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Resolver griefing] Can a resolver set reward_limit to a very low value, making cancellation unprofitable for other resolvers and locking orders until they expire? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Race condition] Multiple resolvers could attempt to cancel the same expired order - does the first one win, or can multiple cancellations succeed? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: cancel_by_resolver()] [Native asset handling] For native assets (line 377 check), tokens are returned to maker_src_ata - but lamports are distributed at line 430 - can wrapped SOL tokens be double-claimed? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: order_hash()] [Hash collision] Lines 753-760 use hashv() to compute order hash - are there known collision attacks against solana_program::hash::hashv that could allow two different orders to have the same hash? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: order_hash()] [Serialization exploit] Line 754 uses order.try_to_vec()? - can an attacker craft OrderConfig with custom serialization that produces the same bytes as another order? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: order_hash()] [Optional parameter manipulation] Lines 755-756 serialize Option<Pubkey> types - can None and Some(Pubkey::default()) serialize to the same bytes, causing collisions? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: order_hash()] [Salt missing] The hash doesn't include any random salt or nonce - can an attacker predict future order hashes to front-run order creation? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: order_hash()] [Parameter ordering] The hash includes parameters in a specific order - can reordering or additional parameters be added without breaking compatibility? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: uni_transfer()] [Native transfer validation] Lines 823-831 perform native SOL transfer - is there validation that 'from' has sufficient lamports, or can this cause account balance to go negative? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: uni_transfer()] [Token transfer validation] Lines 840-852 perform token transfer_checked - if mint.decimals is 0 or invalid, can this cause incorrect transfer amounts? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: uni_transfer()] [Amount zero check] Neither branch checks if amount = 0 - can this be exploited to waste compute units or trigger unexpected behavior in token programs? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: uni_transfer()] [From/to same account] If from and to are the same account, does the transfer succeed or fail? Can this be exploited to appear compliant while not actually transferring? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Function: uni_transfer()] [Reentrancy guard] The function performs CPI calls - are there reentrancy protections to prevent malicious token programs from re-entering? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Create] [Escrow PDA seeds] Lines 446-457 derive escrow PDA from maker, order_hash - can two different makers with carefully chosen keys produce colliding PDAs? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Create] [Unchecked escrow] Line 461 marks escrow as UncheckedAccount - can an attacker provide a pre-existing account that isn't actually a PDA, bypassing security checks? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Create] [Init constraint timing] escrow_src_ata has init constraint at line 470 - can an attacker front-run to create this account with different parameters, causing DoS? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Create] [Maker authentication] Maker is marked as signer at line 480, but what prevents a malicious contract from acting as maker and creating invalid orders? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Create] [Optional maker_src_ata] maker_src_ata is Option<> at line 489 - can the presence/absence mismatch between creation and filling cause issues? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Create] [Unchecked maker_receiver] maker_receiver is UncheckedAccount at line 495 - can an attacker set this to an address they control to redirect funds during fill? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Create] [Optional protocol_dst_acc] protocol_dst_acc is Option<> at line 499 - can its presence/absence be manipulated between create and fill? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Create] [Optional integrator_dst_acc] integrator_dst_acc is Option<> at line 501 - can a malicious integrator frontrun to change this address? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Fill] [Resolver access validation] Lines 511-516 validate resolver_access PDA - can the whitelist program be upgraded to a malicious version that always returns valid? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Fill] [Cross-program seeds] seeds::program = whitelist::ID at line 514 - if whitelist::ID is hardcoded, can this prevent protocol upgrades? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Fill] [Unchecked maker] maker is UncheckedAccount at line 520 - can a resolver provide a fake maker address that matches the PDA but isn't the real maker? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Fill] [Mint validation] src_mint and dst_mint are InterfaceAccount at lines 527-529 - can an attacker provide malicious mint implementations that report false decimals or supply? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Fill] [Taker src_ata constraint] Line 562 only checks taker_src_ata.mint == src_mint - should it also validate authority and token_program? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Fill] [Init_if_needed security] maker_dst_ata uses init_if_needed at line 573 - can a malicious taker repeatedly initialize this account to drain maker of rent? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Fill] [Optional taker_dst_ata] taker_dst_ata is Option<> at line 588 - can a resolver exploit this by setting it to None when dst_asset_is_native is true? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Fill] [Multiple token programs] src_token_program and dst_token_program can be different - can this create inconsistencies in validation or transfer mechanics? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Cancel] [Simplified PDA seeds] Lines 609-613 only use maker and order_hash, not the full order details - can this create ambiguity about which order is being cancelled? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Cancel] [No order validation] Cancel struct doesn't include order config - can a maker cancel with wrong parameters but correct order_hash? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: Cancel] [Optional maker_src_ata] maker_src_ata is Option<> at line 635 - what happens to tokens if this is None for a non-native asset? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: CancelByResolver] [Resolver authentication] Lines 648-652 validate resolver access - can the bump be manipulated to bypass authorization? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: CancelByResolver] [Unchecked maker] maker is UncheckedAccount at line 657 - can a resolver provide a fake maker to redirect lamports? (Critical)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: CancelByResolver] [Unchecked maker_receiver] maker_receiver is UncheckedAccount at line 660 - does this affect order_hash verification? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: FeeConfig] [Protocol fee bounds] protocol_fee is u16 at line 717 - max value is 65535 basis points = 655.35%, can this consume entire dst_amount? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: FeeConfig] [Integrator fee bounds] integrator_fee is u16 at line 720 - combined with protocol_fee, can total fees exceed 100%? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: FeeConfig] [Surplus percentage validation] surplus_percentage is u8 at line 724 - max 255 is validated <= 100 in create(), but could be set higher in a direct call? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: FeeConfig] [Cancellation premium type] max_cancellation_premium is u64 at line 728 - can this exceed the actual lamports in escrow_src_ata? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: OrderConfig] [ID collision] id is u32 at line 733 - can two orders from the same maker have the same ID if order_hash differs? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: OrderConfig] [Amount bounds] src_amount and min_dst_amount are u64 at lines 734-735 - are there practical limits to prevent overflow in calculations? (Medium)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: OrderConfig] [Estimated amount manipulation] estimated_dst_amount at line 736 can be set arbitrarily high - does this enable surplus fee gaming? (High)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: OrderConfig] [Expiration timestamp] expiration_time is u32 at line 737 - what happens after year 2106 when Unix timestamp exceeds u32? (Low)",
  "[File: programs/fusion-swap/src/lib.rs] [Struct: OrderConfig] [Boolean traits] src_asset_is_native and dst_asset_is_native at lines 738-739 - can both be true simultaneously? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: PointAndTimeDelta] [Input validation] Can an attacker create an AuctionData with PointAndTimeDelta entries where time_delta is zero, causing division by zero in the interpolation logic at line 41 when calculate_rate_bump executes, leading to transaction panic and DoS? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: PointAndTimeDelta] [Integer overflow] Can an attacker craft PointAndTimeDelta entries with rate_bump values of u16::MAX (65535) that when multiplied by timestamps in line 39-40 cause u64 overflow despite the overflow comments claiming safety, enabling auction rate manipulation? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: PointAndTimeDelta] [Cumulative overflow] Can an attacker create a points_and_time_deltas vector where the cumulative sum of all time_delta values overflows u64 when added to start_time at line 32, causing incorrect auction timing and potential rate manipulation? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: PointAndTimeDelta] [Rate monotonicity] Does the protocol validate that rate_bump values in consecutive PointAndTimeDelta entries are monotonically decreasing for Dutch auction semantics, or can an attacker create non-decreasing rates to manipulate pricing? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: PointAndTimeDelta] [Vector ordering] Can an attacker provide PointAndTimeDelta entries in non-chronological order within points_and_time_deltas, causing the piecewise interpolation logic to calculate incorrect rates and enable economic exploitation? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Timestamp overflow] Can an attacker set start_time close to u32::MAX such that when duration is added at line 21 (start_time as u64 + duration as u64), it overflows the auction_finish_time calculation, causing auction to never expire? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Zero duration] Can an attacker create an AuctionData with duration=0, causing division by zero at line 71 in calculate_premium or immediate auction finish at line 22-23, enabling instant order fills at initial rates? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Empty vector] Can an attacker provide an empty points_and_time_deltas vector, causing the loop at line 29 to skip entirely and execute the final calculation at lines 52-53 with potentially uninitialized or incorrect current_point_time values? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Excessive vector length] Can an attacker create an AuctionData with an extremely large points_and_time_deltas vector that causes excessive compute unit consumption during iteration at line 29, enabling DoS attacks against order creation or filling? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Rate inversion] Can an attacker set initial_rate_bump lower than subsequent rate_bump values in points_and_time_deltas, causing the Dutch auction to increase prices over time instead of decreasing, violating auction invariants? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Time manipulation] Can an attacker set start_time to a far future timestamp, causing all calls to calculate_rate_bump with current timestamps to return initial_rate_bump at line 19, locking orders at maximum rates indefinitely? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Precision loss] Does the protocol validate that duration is large enough relative to time_delta values to prevent precision loss in division operations at lines 41 and 53, or can an attacker exploit integer division truncation for rate manipulation? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Timestamp comparison] At line 18, can an attacker exploit the <= comparison by providing timestamp exactly equal to start_time to always receive initial_rate_bump even after auction should have started, enabling rate manipulation? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Type casting] Can an attacker exploit the casting of start_time from u32 to u64 at lines 18 and 21 to cause integer overflow or loss of precision when comparing with timestamp parameter? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Auction expiration] At lines 22-23, can an attacker exploit the >= comparison to receive zero rate_bump at exact auction_finish_time, or should it use strict > to ensure non-zero rates until the last moment? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Rate initialization] At line 26, if data.initial_rate_bump is zero, does the entire auction calculation degrade to always returning zero, enabling free order fills or DoS? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Time overflow check] Does line 21's addition (data.start_time as u64 + data.duration as u64) properly handle the case where both are near their maximum values, or can this overflow and cause auction_finish_time to wrap around? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Loop iteration] Can an attacker create a points_and_time_deltas vector with duplicate or overlapping time ranges that causes the loop at line 29 to process multiple entries for the same timestamp, leading to incorrect rate calculations? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Time accumulation] At line 32 (next_point_time = current_point_time + point_time_delta), can an attacker craft time_delta values that cause next_point_time to overflow u64, breaking the timestamp comparisons in subsequent iterations? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Boundary condition] At line 34, can an attacker exploit the <= comparison such that when timestamp exactly equals next_point_time, the interpolation formula at lines 39-41 degenerates to returning next_rate_bump without proper validation? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Division by zero] At line 41, despite the comment claiming point_time_delta cannot be zero, can an attacker construct points_and_time_deltas entries with time_delta=0 that survive any upstream validation and cause division by zero here? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Interpolation overflow] At lines 39-40, can the multiplication operations (timestamp - current_point_time) * next_rate_bump and (next_point_time - timestamp) * current_rate_bump overflow u64 with carefully chosen timestamp and rate_bump values, despite overflow safety claims? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Subtraction underflow] At line 39, can (timestamp - current_point_time) underflow if timestamp < current_point_time due to logic errors in previous iterations or malformed data, causing transaction panic? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Subtraction underflow] At line 40, can (next_point_time - timestamp) underflow if next_point_time < timestamp, violating the assumption at line 34 and causing calculation errors? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Precision loss] Does the division at line 41 cause significant precision loss when point_time_delta is small relative to the numerator, enabling attackers to exploit rounding errors for favorable rates? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [State update] At lines 44-45, after updating current_rate_bump and current_point_time, can inconsistent state between these variables cause incorrect calculations in the final block at lines 52-53? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Loop termination] Can an attacker create points_and_time_deltas where the loop never satisfies the condition at line 34, causing all iterations to skip the return statement and always execute the fallback calculation at lines 52-53? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Final subtraction] At line 52, can (auction_finish_time - timestamp) underflow if timestamp > auction_finish_time due to race conditions or timestamp manipulation, causing transaction panic? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Final subtraction] At line 53, can (auction_finish_time - current_point_time) underflow if current_point_time >= auction_finish_time after loop processing, causing division by zero or underflow? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Division by zero] At line 53, if auction_finish_time equals current_point_time, does the division by zero cause transaction panic, and can an attacker craft AuctionData to trigger this? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Final multiplication overflow] At line 52, can current_rate_bump * (auction_finish_time - timestamp) overflow u64 with maximum rate_bump and duration values, despite overflow safety comments? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Precision in final calculation] Does the final division at line 53 properly handle cases where (auction_finish_time - current_point_time) is very large, causing extreme precision loss and rate manipulation? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Auction completion edge case] If the loop processes all points but timestamp is exactly between the last point and auction_finish_time, can the final calculation at lines 52-53 produce incorrect rates due to stale current_point_time? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Rate declining validation] Does the function validate that the calculated rate_bump is always less than or equal to the previous rate, or can timing exploits cause rate increases in violation of Dutch auction principles? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Timestamp comparison] At line 62, can an attacker exploit the <= comparison to bypass premium charges by providing timestamp exactly equal to auction_start_time, enabling free cancellations? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Zero premium] At line 63, returning 0 premium when timestamp <= auction_start_time could enable attackers to cancel orders before auction starts without penalty, but is this intended behavior or exploitable? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Time calculation] At line 66 (timestamp - auction_start_time), can this subtraction underflow if auction_start_time > timestamp due to type casting or validation bypass, causing transaction panic? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Duration comparison] At line 67, can an attacker set auction_duration to 0 to trigger the >= condition and immediately receive max_cancellation_premium at line 68, enabling premium manipulation? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Maximum premium return] At line 68, returning max_cancellation_premium when time_elapsed >= auction_duration could be exploited if max_cancellation_premium is set to an extremely high value, enabling excessive fee extraction? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Type casting in calculation] At line 71, can the casting of time_elapsed and auction_duration to u64 cause overflow or precision loss when multiplied, enabling premium manipulation? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Multiplication overflow] At line 71, can (time_elapsed as u64 * max_cancellation_premium) overflow u64 if both values are near their maximum, causing incorrect premium calculations or transaction panic? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Division by zero] At line 71, if auction_duration is zero despite the check at line 67, can this cause division by zero in the premium calculation? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Precision loss] Does the integer division at line 71 cause significant rounding down of premiums, enabling attackers to exploit timing to minimize cancellation costs? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Linear premium assumption] Does the linear premium calculation at line 71 properly reflect economic incentives, or can resolvers exploit the linear growth to cancel orders at optimal times for maximum profit extraction? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Premium boundary] At the exact moment when time_elapsed equals auction_duration, does the function return max_cancellation_premium (line 68) or calculate it (line 71), and can this boundary be exploited? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Functions: calculate_rate_bump + calculate_premium] [Timestamp consistency] Can an attacker exploit inconsistencies between how calculate_rate_bump (using u64 timestamp) and calculate_premium (using u32 timestamp) handle time, causing arbitrage opportunities or state inconsistencies? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Functions: calculate_rate_bump + calculate_premium] [Duration mismatch] If AuctionData.duration and the auction_duration parameter in calculate_premium differ, can this create exploitable timing windows where premiums don't align with auction phases? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Functions: calculate_rate_bump + calculate_premium] [Time synchronization] Can an attacker exploit Clock differences between when calculate_rate_bump and calculate_premium are called in the same transaction to manipulate both rate and premium calculations? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Functions: Both functions] [Max value exploitation] Can an attacker set max_cancellation_premium extremely high while keeping auction rates low, creating economic imbalance where cancellation premiums exceed order values? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [Caller validation] Does the calling code in lib.rs validate that the timestamp parameter passed to calculate_rate_bump is from a trusted Clock sysvar, or can attackers provide manipulated timestamps to exploit rate calculations? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [AuctionData source] Are AuctionData structs validated and sanitized before being passed to calculate_rate_bump, or can malicious order creators embed exploit data in auction parameters during order creation? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [Return value validation] Does the calling code validate that calculate_rate_bump never returns a rate_bump higher than initial_rate_bump, or can calculation errors cause rate increases that violate auction logic? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [Premium usage] How is the premium returned by calculate_premium used in cancel_by_resolver - can a malicious resolver exploit premium calculation to extract excessive fees from order creators? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [Rate application] When calculate_rate_bump returns a rate, how is it applied to src_amount and dst_amount calculations - can precision loss in downstream multiplication/division operations be exploited? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [Multiple calls] Can an attacker call calculate_rate_bump multiple times in the same transaction with different timestamps to observe rate changes and exploit timing for optimal fill prices? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [Zero rate handling] If calculate_rate_bump returns 0 after auction expiration (line 23), does the calling code properly handle this to prevent division by zero or other calculation errors? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Interpolation correctness] Does the piecewise linear interpolation at lines 39-41 correctly implement the intended auction curve, or can rounding errors accumulate to cause significant rate deviations? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Continuity] When transitioning between interpolation segments at line 44-45, does the rate calculation maintain continuity, or can there be sudden rate jumps exploitable by resolvers? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Overflow safety validation] Are the overflow safety comments at lines 35-41 and 48-53 mathematically proven, or do edge cases exist where u64 overflow can still occur with extreme input values? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Linear assumption] Does the linear premium growth at line 71 properly incentivize resolver behavior, or can economic attacks exploit the predictable premium curve? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Rate monotonicity] Does the function guarantee that rate_bump decreases monotonically over time as expected in Dutch auctions, or can specific AuctionData configurations cause rate increases? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Start time boundary] What happens if timestamp is exactly start_time + 1 nanosecond - does line 18 handle this correctly or is there an off-by-one error? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Finish time boundary] What happens if timestamp is exactly auction_finish_time - 1 - does the interpolation or final calculation handle this boundary correctly? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Single point] If points_and_time_deltas contains only one entry, does the function handle this correctly or can edge cases in the loop logic cause incorrect rates? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Max u16 rates] If all rate_bump values are set to u16::MAX (65535), can the multiplication at lines 39-40 overflow despite being cast to u64? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Max u32 times] If start_time and duration are both close to u32::MAX, can the addition at line 21 overflow the u64 cast? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Instant cancellation] If auction_start_time equals timestamp at line 62, does returning 0 premium allow free immediate cancellations that violate economic security? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Max duration] If auction_duration is u32::MAX, can the multiplication at line 71 overflow when combined with max_cancellation_premium? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Zero max premium] If max_cancellation_premium is 0, does the function return 0 at line 71, enabling free cancellations throughout the auction? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Attack: Front-running] Can a resolver observe pending orders in mempool and calculate their exact rate_bump using calculate_rate_bump to front-run fills at optimal pricing moments? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Attack: Timestamp manipulation] Can validator-level timestamp manipulation exploit the timestamp dependency in calculate_rate_bump to provide favorable rates to colluding resolvers? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Attack: Compute exhaustion] Can an attacker create AuctionData with thousands of points_and_time_deltas entries to exhaust compute units during calculate_rate_bump execution, causing DoS? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Attack: Precision exploitation] Can an attacker craft AuctionData with specific time_delta values that maximize integer division rounding errors in their favor across multiple orders? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Attack: Rate curve manipulation] Can an order creator craft malicious points_and_time_deltas to create auction curves that appear fair initially but suddenly jump to extreme rates at specific times? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Attack: Premium avoidance] Can a malicious resolver exploit timing or premium calculation at line 71 to cancel orders repeatedly with minimal premiums, griefing order creators? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Attack: Economic griefing] Can an attacker create orders with duration=1 second and max_cancellation_premium=1 lamport to enable instant nearly-free cancellations that disrupt protocol operations? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Attack: Rate starvation] Can an attacker set initial_rate_bump to 0 in AuctionData, causing calculate_rate_bump to always return 0 and making the order unfillable as a griefing attack? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: PointAndTimeDelta] [Serialization] Can an attacker exploit AnchorSerialize/AnchorDeserialize at line 3 to inject malformed PointAndTimeDelta data that bypasses validation but causes exploits in calculate_rate_bump? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Serialization] Can an attacker exploit AnchorSerialize/AnchorDeserialize at line 9 to inject malicious AuctionData with invalid vectors or values that survive deserialization? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Clone operation] Does the Clone implementation at line 9 properly handle the Vec<PointAndTimeDelta>, or can deep copy issues cause aliasing or memory corruption in concurrent operations? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: PointAndTimeDelta] [Memory layout] Can the memory layout of rate_bump (u16) and time_delta (u16) at lines 5-6 cause alignment issues or padding exploitation in serialized form? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Struct: AuctionData] [Vector size limits] Does Anchor enforce size limits on points_and_time_deltas vector at line 14, or can an attacker create unbounded vectors causing memory exhaustion? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Type mixing] Can the mixing of u16 (rate_bump, time_delta), u32 (start_time, duration), and u64 (timestamp) types cause subtle casting bugs in arithmetic operations? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Widening casts] Do the widening casts from u16 to u64 (lines 19, 26, 30, 31) properly preserve values, or can sign extension or truncation issues occur? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Type consistency] Can the use of u32 timestamps in calculate_premium versus u64 in calculate_rate_bump cause timing inconsistencies when both are called in the same transaction? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Narrowing cast implications] Does the code elsewhere properly handle the fact that calculate_premium uses u32 timestamps, potentially limiting auction durations? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Empty vector with zero duration] If points_and_time_deltas is empty AND duration is 0, does the function panic, return undefined behavior, or handle gracefully? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [All zero rates] If initial_rate_bump and all point rate_bumps are 0, does calculate_rate_bump always return 0, making orders unfillable? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Identical consecutive rates] If consecutive PointAndTimeDelta entries have identical rate_bump values, does the interpolation degenerate correctly to constant rates? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Single nano-second deltas] Can an attacker use time_delta values of 1 (nanosecond) to create near-infinite points that exhaust compute while passing validation? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Future start time] If start_time is far in the future (e.g., start_time = u32::MAX - 1000), does line 18 correctly handle all timestamps before that time? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Past auction] If auction_start_time is in the far past and auction_duration is small, can timestamp overflow or time_elapsed overflow at line 66? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Max premium value] If max_cancellation_premium is u64::MAX, can the multiplication at line 71 overflow before division? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Loop state preservation] Does the state update at lines 44-45 maintain invariants required for the final calculation at lines 52-53, or can loop execution leave inconsistent state? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Early return vs fallthrough] When the loop returns early at line 41, are there cases where falling through to line 52 would give different results, indicating logic errors? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Point time accumulation] As current_point_time accumulates through loop iterations at line 45, can it exceed auction_finish_time before the loop completes, causing invalid final calculations? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Iteration complexity] What is the computational complexity of the loop at line 29, and can an attacker create AuctionData requiring O(n) iterations with n > compute unit limits? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Worst-case compute] Can an attacker craft AuctionData to maximize compute consumption by forcing execution of all loop iterations plus final calculation? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Compute efficiency] Does calculate_premium's constant-time execution prevent DoS, or can specific input combinations cause unexpected performance degradation? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Rate declining enforcement] Does the auction mechanism ensure resolvers have decreasing incentive to delay fills, or can rate curves be crafted where waiting is optimal? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Premium sufficiency] Does the linear premium at line 71 sufficiently disincentivize malicious resolver cancellations, or can resolvers profit from cancel-and-refill strategies? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Zero-rate exploitation] When rate_bump reaches 0 at line 23, can this enable resolvers to fill orders at arbitrary exchange rates, violating maker expectations? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Premium bypass] Can a resolver exploit the timestamp <= auction_start_time check at line 62 to cancel orders immediately after creation with zero premium? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Interpolation stability] Does the linear interpolation at lines 39-41 remain numerically stable with extreme rate_bump differentials between consecutive points? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Catastrophic cancellation] Can subtraction operations at lines 39-40 cause catastrophic cancellation when timestamp is very close to current_point_time or next_point_time? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Multiplication order] Does the order of operations at line 71 (multiply then divide) minimize precision loss, or should division occur first? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Monotonic decrease invariant] Does the function guarantee that subsequent calls with later timestamps always return lower or equal rate_bump values? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Monotonic increase invariant] Does the function guarantee that subsequent calls with later timestamps always return higher or equal premium values? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Boundary value invariant] Does rate_bump at start_time always equal initial_rate_bump, and at auction_finish_time always equal 0? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Premium bounds invariant] Does premium always satisfy 0 <= premium <= max_cancellation_premium, or can calculation errors violate this bound? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [Clock manipulation] Can malicious validators manipulate Clock sysvar timestamps passed to calculate_rate_bump to provide advantageous rates to colluding resolvers? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [Reentrancy] If calculate_rate_bump or calculate_premium are called multiple times in the same transaction, can reentrancy or state changes between calls cause inconsistent results? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Integration] [Account validation] Does the calling code validate that AuctionData is from a trusted account, or can attackers provide malicious AuctionData from arbitrary accounts? (Critical)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Division remainder] When dividing at lines 41 and 53, does the integer division truncate remainders in a way exploitable by attackers to gain fractional rate advantages? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Multiplication commutativity] Does the order of multiplications at lines 39-40 matter for overflow prevention, or is the current order optimal? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Rounding direction] Does the integer division at line 71 round down premiums, and can this be exploited to pay less than economically fair cancellation costs? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Time unit assumptions] Does the function assume specific time units (seconds, milliseconds, nanoseconds) for timestamp, or can unit mismatches cause rate miscalculations? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Time unit consistency] Are timestamp and auction_start_time in the same time units, or can unit mismatches cause premium calculation errors? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Clock drift] Can clock drift between order creation and fill execution cause timestamp inconsistencies that benefit resolvers? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Timestamp source] If timestamp comes from Clock sysvar, can it be manipulated or delayed to affect premium calculations in resolver's favor? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Rate curve validation] Does the protocol validate that the piecewise linear curve defined by points_and_time_deltas is geometrically valid and doesn't self-intersect? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Point density] Can extremely high-density point arrays (many points in small time ranges) cause precision issues in interpolation calculations? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Terminal rate] Does the function guarantee that the final rate at auction_finish_time is exactly 0, or can numerical errors cause non-zero terminal rates? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Premium continuity] Is the premium function continuous at the auction_duration boundary, or can there be a discontinuity exploitable for arbitrage? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [All functions] [Determinism] Are both functions fully deterministic given the same inputs, or can non-determinism in floating-point operations (if any) cause inconsistent results? (High)",
  "[File: programs/fusion-swap/src/auction.rs] [All functions] [Audit trail] Do these pure functions leave any audit trail for rate/premium calculations, or can malicious calculations occur without on-chain evidence? (Low)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_rate_bump] [Rate application order] Does it matter whether rate_bump is applied before or after fees in token calculations, and can this be exploited? (Medium)",
  "[File: programs/fusion-swap/src/auction.rs] [Function: calculate_premium] [Premium extraction] How is the calculated premium extracted from escrow, and can the extraction mechanism be exploited independently of premium calculation correctness? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: initialize()] [State corruption] Can an attacker call initialize() multiple times if the whitelist_state account is not properly checked for existing initialization, allowing them to overwrite the authority and take control of the entire whitelist system? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: initialize()] [Authority takeover] Does the initialize() function validate that the authority signer is an expected address, or can any arbitrary account call initialize() during deployment and claim authority over the whitelist, enabling complete access control bypass? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: initialize()] [PDA collision] Can an attacker predict the whitelist_state PDA seed derivation and front-run the legitimate initialization transaction to initialize the account with their own authority, permanently locking out the protocol administrators? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: initialize()] [Rent exemption] If the whitelist_state account space calculation (DISCRIMINATOR + WhitelistState::INIT_SPACE) is incorrect, can this lead to rent collection that closes the account, causing all resolver access checks to fail and halting the entire protocol? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: initialize()] [DoS attack] Can an attacker repeatedly initialize and close the whitelist_state account through a vulnerability in account closure checks, preventing legitimate initialization and causing protocol-wide DoS? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: initialize()] [Initialization race] If multiple transactions attempt to initialize() simultaneously, can this lead to undefined behavior where multiple authorities are set, or can one transaction override another's authority setting? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Function: initialize()] [Missing validation] Does initialize() validate that the authority parameter is not a system account (e.g., SystemProgram, null address), which could permanently brick the whitelist by setting an unusable authority? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: initialize()] [Payer exploitation] Can a malicious payer set during initialize() extract rent fees or manipulate account initialization to gain unauthorized benefits, leading to economic attacks on protocol deployment? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Access control bypass] Can an attacker bypass the authority constraint check at line 70 by providing a valid whitelist_state but using a compromised or fake authority signer, allowing unauthorized resolver registration? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [PDA collision] Can an attacker pre-compute resolver_access PDAs for multiple addresses and register malicious resolvers before legitimate ones, enabling them to fill orders with manipulated terms? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Duplicate registration] If register() is called multiple times for the same user, does it properly handle already-initialized resolver_access accounts, or can this lead to state corruption or rent drain through repeated initialization attempts? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [User parameter manipulation] Can an attacker pass a different user pubkey in the instruction parameter versus what's used in the resolver_access PDA seeds, causing mismatch between the registered resolver and the PDA, enabling unauthorized access? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Bump seed manipulation] The register() function stores the bump at line 26, but can an attacker manipulate this bump value during registration to create resolver_access accounts that pass PDA validation but don't match expected derivations? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Sybil attack] Can a compromised authority register an unlimited number of resolver addresses in a single transaction or through flash loan attacks, overwhelming the whitelist and enabling mass order manipulation? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Cross-program exploitation] If the register() function is called via CPI from another program, can that program bypass authority checks or inject malicious resolver addresses without proper validation? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Rent drain attack] Can an attacker cause the authority to register many resolver accounts then immediately deregister them, draining the authority's SOL through repeated rent payments and refunds? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Authority front-running] Can an attacker monitor mempool for register() transactions and front-run them to register malicious resolvers first, stealing order-filling opportunities from legitimate resolvers? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Space calculation exploit] If ResolverAccess::INIT_SPACE is incorrectly calculated, can this lead to buffer overflows, memory corruption, or account truncation that breaks resolver access validation? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Zero address registration] Can the register() function be called with a zero pubkey or system program address as the user parameter, creating invalid resolver_access accounts that break access control logic? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: register()] [Program ID spoofing] Can an attacker create a fake whitelist program with the same interface and use it to register resolvers that appear valid but bypass actual authorization checks in the fusion-swap program? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [Access control bypass] Can an attacker bypass the authority constraint at line 96 to deregister legitimate resolvers, causing DoS by preventing authorized resolvers from filling orders? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [PDA collision] Can an attacker provide a crafted user pubkey that results in a valid resolver_access PDA for a different user, allowing them to deregister other resolvers and monopolize order filling? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [Rent recipient manipulation] The deregister() function closes the resolver_access account to the authority at line 102, but can an attacker manipulate this to redirect rent refunds to a malicious address, stealing SOL? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [Double deregister] Can deregister() be called on an already-closed resolver_access account, causing unexpected behavior, rent drain, or breaking protocol invariants? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [Race condition] If a resolver is being deregistered while simultaneously filling an order in another transaction, can this create race conditions that allow unauthorized order fills or state corruption? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [Malicious resolver griefing] Can a compromised authority deregister all resolvers in a coordinated attack, halting all order fills across the protocol and causing complete DoS? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [User parameter mismatch] Can an attacker pass incorrect user parameter that doesn't match the actual resolver_access account being closed, bypassing validation and closing wrong accounts? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [Bump validation bypass] Does deregister() properly validate the bump seed of the resolver_access account, or can an attacker provide accounts with incorrect bumps that still pass PDA validation? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [Cross-program deregister] If deregister() is called via CPI from an unauthorized program, can this bypass authority checks and allow malicious programs to remove legitimate resolvers? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: deregister()] [Incomplete deregistration] After closing the resolver_access account, can stale data or references in other programs continue to treat the address as a valid resolver, bypassing access control? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Authority takeover] Can an attacker exploit set_authority() to change the authority to their own address, gaining complete control over resolver registration/deregistration and breaking protocol security? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Authority constraint bypass] Can the authority constraint at line 120 be bypassed through account substitution, signature replay, or PDA manipulation, allowing unauthorized authority changes? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Zero address authority] Can set_authority() be called with a zero address or system program as new_authority, permanently bricking the whitelist by setting an unusable authority? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Front-running attack] Can an attacker monitor mempool for set_authority() transactions and front-run them to set their own authority before the legitimate change occurs? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Compromised key rotation] If the current authority private key is compromised, can an attacker use set_authority() to lock out the legitimate authority before they can rotate to a safe key? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Multi-sig bypass] Does set_authority() support multi-signature requirements for authority changes, or can a single compromised key transfer complete control of the whitelist? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Timelock absence] Can set_authority() be called immediately to change authority without timelock delays, enabling rapid takeover attacks before response is possible? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Event emission] Does set_authority() emit proper events for authority changes, or can attackers silently change authority without detection or audit trail? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Authority validation] Does set_authority() validate that new_authority is a valid signer-capable account (not a PDA or program), preventing lockout scenarios? (High)",
  "[File: programs/whitelist/src/lib.rs] [Function: set_authority()] [Circular authority] Can set_authority() be exploited to create circular authority references or invalid state where authority changes cannot be reverted? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Constants: WHITELIST_STATE_SEED] [PDA collision] Can an attacker predict the whitelist_state PDA from WHITELIST_STATE_SEED (b'whitelist_state') and create a colliding account on a different program to interfere with whitelist operations? (High)",
  "[File: programs/whitelist/src/lib.rs] [Constants: RESOLVER_ACCESS_SEED] [PDA collision] Can an attacker exploit RESOLVER_ACCESS_SEED (b'resolver_access') combined with user pubkeys to create PDA collisions that allow impersonating legitimate resolvers? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Constants: WHITELIST_STATE_SEED] [Cross-program collision] Can different programs using the same seed 'whitelist_state' create conflicting PDAs that break access control assumptions in the fusion-swap program? (High)",
  "[File: programs/whitelist/src/lib.rs] [Constants: RESOLVER_ACCESS_SEED] [Seed grinding] Can an attacker grind for user pubkeys that produce resolver_access PDAs with favorable properties (specific bumps, addresses) to exploit validation logic? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Constants: Both seeds] [Program ID dependency] If the program ID changes during upgrade, do the PDA seeds produce different addresses that break existing resolver registrations and access control? (High)",
  "[File: programs/whitelist/src/lib.rs] [Struct: WhitelistState] [Authority field manipulation] Can the WhitelistState.authority field be directly modified through memory corruption, account reallocation, or other exploits, bypassing set_authority()? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Struct: WhitelistState] [Account reallocation] Can an attacker reallocate the whitelist_state account to a larger size and inject malicious data that corrupts the authority field? (High)",
  "[File: programs/whitelist/src/lib.rs] [Struct: WhitelistState] [Discriminator bypass] Can an attacker create fake WhitelistState accounts with valid discriminators but malicious authority values, bypassing PDA validation? (High)",
  "[File: programs/whitelist/src/lib.rs] [Struct: WhitelistState] [Space calculation] If WhitelistState::INIT_SPACE is incorrectly calculated, can this lead to account truncation or buffer overflow that corrupts the authority field? (High)",
  "[File: programs/whitelist/src/lib.rs] [Struct: WhitelistState] [Deserialization exploit] Can malformed data in the whitelist_state account cause deserialization errors that bypass authority checks or lead to exploitable behavior? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Struct: ResolverAccess] [Bump manipulation] Can an attacker manipulate the ResolverAccess.bump field to create resolver_access accounts that pass PDA validation with incorrect seeds? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Struct: ResolverAccess] [Bump zero value] If ResolverAccess.bump is set to 0 or an invalid value during registration, can this break PDA validation in the fusion-swap program and allow unauthorized access? (High)",
  "[File: programs/whitelist/src/lib.rs] [Struct: ResolverAccess] [Bump overflow] Can the bump value overflow or underflow in scenarios where it's used in calculations, leading to incorrect PDA derivation? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Struct: ResolverAccess] [Account data injection] Can an attacker inject additional data beyond the bump field into ResolverAccess accounts, potentially exploiting deserialization vulnerabilities? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Struct: ResolverAccess] [Space calculation] If ResolverAccess::INIT_SPACE is incorrect, can this lead to account corruption or allow attackers to store extra data in resolver accounts? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [CPI: fusion-swap integration] When fusion-swap program validates resolver_access PDAs at lines 511-516, can an attacker provide fake resolver_access accounts from a different program that pass validation? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [CPI: Program ID validation] Can an attacker deploy a malicious whitelist program with the same interface but different ID, causing fusion-swap to accept invalid resolver_access accounts? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [CPI: Reentrancy] Can the whitelist program be exploited through reentrancy attacks where CPI calls back to the whitelist program during register/deregister operations? (High)",
  "[File: programs/whitelist/src/lib.rs] [CPI: Account substitution] When fusion-swap validates resolver_access through CPI, can an attacker substitute resolver_access accounts that belong to different users but have the same bump? (High)",
  "[File: programs/whitelist/src/lib.rs] [CPI: State desync] Can the whitelist_state authority be changed while resolver_access accounts are being validated in fusion-swap, causing state desynchronization? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Context: Initialize] [Authority signer bypass] Can the authority signer check be bypassed by providing a fake signature or exploiting Solana's signature verification? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Context: Initialize] [Whitelist state PDA] Can an attacker provide a pre-existing account at the whitelist_state PDA address that passes seeds validation but contains malicious data? (High)",
  "[File: programs/whitelist/src/lib.rs] [Context: Initialize] [Init constraint] Does the init constraint properly prevent re-initialization, or can an attacker call initialize() on an existing account? (High)",
  "[File: programs/whitelist/src/lib.rs] [Context: Initialize] [Payer exploitation] Can a malicious payer refuse to pay rent or manipulate the initialization to cause transaction failure and DoS? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Context: Initialize] [System program substitution] Can an attacker provide a fake system_program account that allows malicious initialization behavior? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Context: Register] [Authority constraint] At line 70, can the constraint 'whitelist_state.authority == authority.key()' be bypassed through account data manipulation? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Context: Register] [Resolver access init] Can the init constraint on resolver_access at line 75 be exploited to re-initialize existing accounts or cause state corruption? (High)",
  "[File: programs/whitelist/src/lib.rs] [Context: Register] [Seeds validation] Can an attacker provide resolver_access accounts with incorrect seeds that still pass the seeds constraint at lines 78-79? (High)",
  "[File: programs/whitelist/src/lib.rs] [Context: Register] [Bump derivation] Is the bump derivation secure against manipulation where an attacker provides accounts with pre-calculated bumps? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Context: Register] [User parameter injection] Can an attacker inject malicious data through the user parameter that causes unexpected behavior in PDA derivation? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Context: Deregister] [Authority constraint] At line 96, can the authority constraint be bypassed to allow unauthorized deregistration? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Context: Deregister] [Close constraint] Can the close constraint at line 102 be exploited to close wrong accounts or redirect rent to attackers? (High)",
  "[File: programs/whitelist/src/lib.rs] [Context: Deregister] [Seeds validation] Can resolver_access seeds validation at lines 103-104 be bypassed with crafted user parameters? (High)",
  "[File: programs/whitelist/src/lib.rs] [Context: Deregister] [Double close] Can the same resolver_access account be closed multiple times, draining rent or causing state corruption? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Context: Deregister] [Rent refund] Can an attacker manipulate the authority account to intercept rent refunds from deregistered accounts? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Context: SetAuthority] [Current authority check] At line 120, can the constraint verifying current_authority be bypassed through signature replay or account substitution? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Context: SetAuthority] [Whitelist state mutability] Can the whitelist_state account mutation at line 116 be exploited to corrupt other fields or cause state inconsistencies? (High)",
  "[File: programs/whitelist/src/lib.rs] [Context: SetAuthority] [Seeds validation] Can whitelist_state PDA validation at lines 117-118 be bypassed with a fake account? (High)",
  "[File: programs/whitelist/src/lib.rs] [Context: SetAuthority] [New authority validation] Is new_authority validated to ensure it's not a system account, PDA, or invalid address? (High)",
  "[File: programs/whitelist/src/lib.rs] [Context: SetAuthority] [State persistence] After set_authority() executes, can the old authority still perform actions due to stale state or race conditions? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Error: WhitelistError::Unauthorized] Can the Unauthorized error be silently caught and bypassed by malicious programs calling the whitelist via CPI? (High)",
  "[File: programs/whitelist/src/lib.rs] [Error handling: General] Are all critical operations properly wrapped in Result types, or can errors be ignored to bypass security checks? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Error handling: Panic] Can any function panic instead of returning errors, causing transaction failure and potential DoS? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Program ID: declare_id] Can the program ID at line 7 be spoofed or replaced during deployment to create a malicious whitelist program? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Program ID: Validation] Do other programs properly validate they're calling the correct whitelist program ID, or can attackers substitute fake programs? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Program ID: Upgrade] If the program is upgraded, can the program ID change in ways that break PDA derivations or access control? (High)",
  "[File: programs/whitelist/src/lib.rs] [Accounts: Signer validation] Can any signer requirements be bypassed through fake signatures, replayed signatures, or signature malleability? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Accounts: Mut validation] Are all mutable accounts properly validated, or can attackers modify accounts that should be immutable? (High)",
  "[File: programs/whitelist/src/lib.rs] [Accounts: Owner validation] Does the program validate that accounts are owned by expected programs, or can attackers provide accounts owned by malicious programs? (High)",
  "[File: programs/whitelist/src/lib.rs] [Accounts: Size validation] Are account sizes validated to prevent buffer overflows or truncation attacks? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [State: Initialization ordering] If register() is called before initialize(), can this lead to undefined behavior or state corruption? (High)",
  "[File: programs/whitelist/src/lib.rs] [State: Concurrent operations] Can simultaneous register/deregister operations on the same resolver cause race conditions or state inconsistencies? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [State: Atomicity] Are all state transitions atomic, or can partial failures leave the whitelist in an inconsistent state? (High)",
  "[File: programs/whitelist/src/lib.rs] [State: Rollback] If a transaction fails mid-execution, are state changes properly rolled back or can partial state persist? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Integration: Fill validation] When fusion-swap's Fill instruction validates resolver_access at lines 511-516, can an attacker provide stale or revoked resolver_access accounts? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Integration: CancelByResolver validation] When fusion-swap's CancelByResolver validates resolver_access at lines 648-653, can timing attacks allow deregistered resolvers to cancel orders? (High)",
  "[File: programs/whitelist/src/lib.rs] [Integration: PDA derivation mismatch] Can differences in PDA derivation between whitelist and fusion-swap programs create validation bypass opportunities? (High)",
  "[File: programs/whitelist/src/lib.rs] [Integration: Program account validation] Does fusion-swap properly validate that resolver_access accounts come from the correct whitelist program using seeds::program? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Integration: Bump validation] When fusion-swap checks resolver_access.bump, can an attacker provide accounts with manipulated bumps that still pass validation? (High)",
  "[File: programs/whitelist/src/lib.rs] [Economic: Registration spam] Can an attacker spam register() to create massive numbers of resolver_access accounts, exhausting protocol resources? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Economic: Rent drain] Can repeated register/deregister cycles drain the authority's SOL through rent payments? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Economic: Compute exhaustion] Can malicious inputs cause register/deregister operations to consume maximum compute units, enabling DoS attacks? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Economic: Front-running] Can attackers monitor and front-run register() transactions to register resolvers before legitimate parties? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Access: Direct account creation] Can an attacker directly create resolver_access accounts without going through register(), bypassing authority checks? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Access: Stale resolver check] After deregistration, can old resolver_access account data remain accessible, allowing deregistered resolvers to fill orders? (High)",
  "[File: programs/whitelist/src/lib.rs] [Access: Cross-chain bypass] Can an attacker exploit cross-chain bridges or oracles to create valid-looking resolver_access accounts? (Low)",
  "[File: programs/whitelist/src/lib.rs] [DoS: Whitelist state closure] Can an attacker close the whitelist_state account, causing all register/deregister operations to fail? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [DoS: Authority lockout] Can set_authority() be exploited to set an invalid authority, permanently locking out all administrative functions? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [DoS: Mass deregistration] Can a compromised authority deregister all resolvers simultaneously, halting order fills across the protocol? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [DoS: PDA griefing] Can an attacker grief PDA derivation by creating accounts at expected addresses, preventing legitimate registrations? (High)",
  "[File: programs/whitelist/src/lib.rs] [DoS: Compute limit] Can specially crafted transactions cause register/deregister to exceed compute limits, making operations impossible? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Upgrade: Account migration] If the program is upgraded with new account structures, can this break existing resolver_access accounts? (High)",
  "[File: programs/whitelist/src/lib.rs] [Upgrade: PDA changes] If PDA derivation logic changes in an upgrade, can this invalidate existing resolver registrations? (High)",
  "[File: programs/whitelist/src/lib.rs] [Upgrade: Authority preservation] Does the program ensure authority is preserved across upgrades, or can upgrade reset the authority? (High)",
  "[File: programs/whitelist/src/lib.rs] [Upgrade: Backwards compatibility] Are upgrades backwards compatible with existing resolver_access accounts, or can upgrades break access control? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Crypto: Signature verification] Are all signatures properly verified using Solana's built-in verification, or can fake signatures be accepted? (Critical)",
  "[File: programs/whitelist/src/lib.rs] [Crypto: PDA derivation] Is PDA derivation cryptographically secure against preimage attacks where attackers find colliding seeds? (High)",
  "[File: programs/whitelist/src/lib.rs] [Crypto: Bump grinding] Can attackers grind for specific bump values that create exploitable PDA addresses? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Validation: User pubkey] In register() and deregister(), is the user pubkey validated to prevent zero addresses, system accounts, or invalid keys? (High)",
  "[File: programs/whitelist/src/lib.rs] [Validation: Authority pubkey] In set_authority(), is new_authority validated to ensure it's a valid, signable account? (High)",
  "[File: programs/whitelist/src/lib.rs] [Validation: Account discriminator] Are account discriminators properly validated to prevent fake accounts from passing as WhitelistState or ResolverAccess? (High)",
  "[File: programs/whitelist/src/lib.rs] [Validation: Seeds] Are PDA seeds validated to prevent injection attacks or seed manipulation? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Timing: Registration delay] Can an attacker exploit timing between register() and when the resolver becomes active to fill orders before registration completes? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Timing: Deregistration race] Can a resolver fill orders between when deregister() is called and when the account is actually closed? (High)",
  "[File: programs/whitelist/src/lib.rs] [Timing: Authority change race] Can operations use the old authority during the window when set_authority() is executing? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Ordering: Operation sequence] Can changing the order of operations (e.g., deregister before register) create exploitable states? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Edge case: Empty whitelist] If all resolvers are deregistered, can this create a DoS state where no orders can be filled? (High)",
  "[File: programs/whitelist/src/lib.rs] [Edge case: Maximum resolvers] Is there a limit on the number of registered resolvers, or can unlimited registrations exhaust resources? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Edge case: Self-registration] Can the authority register themselves as a resolver, creating conflicts of interest? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Edge case: Program as resolver] Can a program account be registered as a resolver, enabling automated exploit scripts? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Edge case: Duplicate authority] Can set_authority() be called with the same authority as current, wasting gas or causing state issues? (Low)",
  "[File: programs/whitelist/src/lib.rs] [Advanced: Flash loan attack] Can an attacker use flash loans to temporarily control the authority and register malicious resolvers? (High)",
  "[File: programs/whitelist/src/lib.rs] [Advanced: MEV exploitation] Can MEV bots exploit register/deregister transactions to manipulate resolver competition in the fusion-swap program? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Advanced: Governance attack] If authority is controlled by governance, can governance attacks change authority or register malicious resolvers? (High)",
  "[File: programs/whitelist/src/lib.rs] [Advanced: Composability exploit] Can other protocols composing with whitelist create vulnerabilities through unexpected interactions? (Medium)",
  "[File: programs/whitelist/src/lib.rs] [Advanced: Account resurrection] After deregistration, can resolver_access accounts be resurrected with different data, bypassing checks? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [PDA collision] In the calculateOrderHash() call at line 78, can an attacker craft two different orders with different parameters (srcAmount, minDstAmount, fees) that produce the same order hash, causing PDA collision and allowing the second order to overwrite or steal funds from the first order's escrow? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Hash manipulation] Does the order hash calculation at line 78 via calculateOrderHash() properly include all order parameters in a collision-resistant manner, or can an attacker manipulate non-included fields to create orders with identical hashes but different execution behavior? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [PDA seed manipulation] In the findEscrowAddress() call at lines 89-93, can an attacker manipulate the maker address or order hash buffer to derive an existing escrow PDA controlled by another user, allowing unauthorized access to that escrow's funds? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Buffer encoding attack] At lines 89-93, the order hash is passed as Buffer.from(orderHash) to findEscrowAddress() - can an attacker exploit buffer encoding inconsistencies between the hash calculation and PDA derivation to create PDA collisions? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Order hash serialization] The orderHash is calculated at line 78 and logged as hex at line 79, but is there validation that the serialization format matches what the on-chain program expects, potentially causing escrow derivation mismatches? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Amount validation] At lines 36-37, srcAmount and minDstAmount are accepted as BN types without validation - can an attacker pass zero or negative amounts to create invalid orders that could be exploited during fill operations? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Integer overflow] At lines 165-166, the amount conversion uses Math.pow(10, decimals) and multiplication - can this overflow with large decimal values (e.g., 255 decimals) causing incorrect srcAmount/minDstAmount calculation and potential fund loss? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Decimal manipulation] At lines 158-159, token decimals are fetched from on-chain, but at lines 165-166, can an attacker provide manipulated decimal values to the Math.pow() calculation to create orders with incorrect amounts? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [BN conversion loss] When srcAmount and minDstAmount are passed as BN at lines 36-37 and used in reducedOrderConfig at lines 55-56, is there precision loss or overflow that could allow creating orders with amounts different from user intent? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [estimatedDstAmount manipulation] At line 48, estimatedDstAmount defaults to minDstAmount - can a malicious maker set estimatedDstAmount far below minDstAmount to manipulate auction calculations or fee distributions? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [SOL wrapping race condition] At lines 102-117, when srcMint == NATIVE_MINT, SOL is wrapped by transferring to ATA then syncing - can an attacker front-run this transaction to manipulate the wrapped amount or steal the SOL during the wrap? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [SOL amount mismatch] At line 112, srcAmount.toNumber() is used for lamports transfer - can this lose precision for amounts > 2^53, causing the maker to transfer more SOL than intended to the wrapping ATA? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Unwrapped SOL handling] At lines 109-114, the SystemProgram.transfer() sends lamports directly to the maker's native ATA without checking if the ATA exists - can this cause transaction failure and loss of funds if the ATA hasn't been initialized? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Native mint validation] At line 102, the condition checks srcMint == splToken.NATIVE_MINT, but if srcAssetIsNative is true at line 43 while srcMint is not NATIVE_MINT, does this create inconsistency that could be exploited during order fill? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Sync native timing] At line 116, syncNativeInstruction is called after transfer - if the transaction is interrupted between transfer and sync, can the funds be in an inconsistent state allowing theft? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Double wrapping attack] If the maker's native ATA at line 104-107 already has wSOL balance, does the additional transfer at lines 109-114 cause over-wrapping, and could this be exploited to drain more tokens than the order's srcAmount during fill? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Fee account null validation] At lines 46-47 and 128-129, protocolDstAcc and integratorDstAcc can be null, but in orderConfig at lines 73-74 they're included - can an attacker exploit the mismatch between null accounts and fee percentages to steal fees? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Fee percentage overflow] The fee object at line 45 uses defaultFeeConfig which has protocolFee, integratorFee, surplusPercentage - can an attacker manipulate these to sum > 100%, causing the fill operation to fail or distribute incorrect amounts? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [maxCancellationPremium manipulation] The defaultFeeConfig includes maxCancellationPremium - can a maker set this to an extremely high value to drain resolver funds during cancellation operations? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Fee account mismatch] At lines 71-75, the fee config spreads the reduced fee but adds protocolDstAcc and integratorDstAcc - if these accounts don't match the actual fee recipients expected by the program, can this cause fund misdirection? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Optional fee accounts] Since protocolDstAcc and integratorDstAcc are optional at lines 46-47, but fees might be non-zero in defaultFeeConfig - can this cause the program to attempt fee transfers to null accounts, leading to transaction failure or stuck funds? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Receiver manipulation] At line 42, the receiver defaults to makerKeypair.publicKey but can be overridden - can a malicious maker set receiver to an attacker-controlled address to redirect filled tokens away from the legitimate maker? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Receiver validation] At line 123, makerReceiver is set to the receiver parameter without validation - can an attacker set receiver to system program or a PDA they control to steal filled order proceeds? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Receiver account ownership] When receiver is different from maker at line 42, is there validation that the receiver address is a valid account owned by the maker, or can funds be permanently lost to an invalid address? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Order ID collision] At line 40, orderId is accepted without validation - can an attacker reuse an existing orderId to create a hash collision with a previous order, potentially accessing that order's escrow? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Order ID overflow] At line 151, orderId is read as Number() without bounds checking - can an attacker provide orderId > u32::MAX causing overflow when the value is used in reducedOrderConfig at line 54? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Order ID uniqueness] The orderId at line 40 is part of the order hash calculation, but is there off-chain tracking to prevent makers from reusing the same orderId with different parameters to confuse tracking systems? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Expiration time manipulation] At line 41, expirationTime defaults to defaultExpirationTime() but can be overridden - can an attacker set expirationTime in the past to create already-expired orders that bypass certain validations? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Expiration overflow] The expirationTime is a number type at line 41, but should be u32 based on the schema - can overflow occur if a large timestamp is provided, causing the order to have incorrect expiration validation? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Far future expiration] Can a maker set expirationTime to u32::MAX at line 41 to create orders that never expire, potentially locking funds indefinitely in escrow if the order is never filled? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Dutch auction manipulation] At line 49, dutchAuctionData defaults to defaultAuctionData - can an attacker craft custom auction parameters with startTime in the far future (0xffffffff - 32000 per utils.ts) to manipulate when the order becomes fillable? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Auction duration overflow] At line 50, cancellationAuctionDuration defaults to defaultAuctionData.duration (32000) - can an attacker set this to 0 or u32::MAX to manipulate cancellation premium calculations? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Rate bump manipulation] The dutchAuctionData includes initialRateBump and pointsAndTimeDeltas - can a maker craft these to create auction curves that never reach favorable rates for resolvers, causing orders to remain unfilled? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Auction start time bypass] If dutchAuctionData.startTime at line 49 is set to 0 or far past, can this cause the auction price calculation to behave incorrectly, allowing unfair fills? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Token program substitution] At line 51, srcTokenProgram defaults to TOKEN_PROGRAM_ID but can be overridden - can an attacker provide a malicious token program address to bypass token transfer validations during escrow funding? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Token program mismatch] At line 127, srcTokenProgram is passed to the create instruction - if this doesn't match the actual program owning the srcMint, can this cause the escrow funding to fail silently or be exploited? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [TOKEN_2022 incompatibility] The default srcTokenProgram at line 51 is TOKEN_PROGRAM_ID - if the srcMint is actually a Token-2022 token with extensions, can this cause incorrect escrow accounting or token loss? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Native flag mismatch] At lines 43-44, srcAssetIsNative and dstAssetIsNative can be set independently of the actual mint types - can an attacker set srcAssetIsNative=true while srcMint is not NATIVE_MINT to bypass SOL wrapping and steal tokens? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Native flag validation] The native flags at lines 43-44 and 59-60 are used in the order config without validation against actual mint addresses - can this cause the fill operation to incorrectly wrap/unwrap tokens? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Double native handling] If both srcAssetIsNative and dstAssetIsNative are true at lines 43-44, does the program correctly handle SOL-to-SOL swaps, or can this cause escrow confusion and fund loss? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Transaction ordering] At lines 100-134, instructions are added to the transaction in a specific order - can an attacker manipulate transaction ordering to execute SOL wrap after the create instruction, bypassing escrow funding? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Partial transaction execution] If the transaction at lines 136-138 fails after the SOL transfer at line 109-114 but before the create instruction, are the transferred lamports stuck in the maker's native ATA? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Instruction batching limits] Can an attacker create scenarios where the transaction at lines 100-138 exceeds compute unit limits, causing consistent failures and DoS of order creation? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Signer validation] At line 131, only makerKeypair is listed as signer, and again at line 137 - can an attacker exploit missing multi-sig validation if the maker account is meant to require multiple signers? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Escrow ATA collision] At lines 94-98, escrowAta is derived using getAssociatedTokenAddress() with allowOwnerOffCurve=true - can an attacker create an order where this ATA already exists with different ownership, causing fund misdirection? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [ATA derivation mismatch] The escrowAta at lines 94-98 uses the escrow PDA as owner and srcMint as mint - if these don't match what the on-chain program expects, can tokens be transferred to an incorrect ATA? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [allowOwnerOffCurve risk] At line 97, allowOwnerOffCurve is set to true - can this allow deriving ATAs for PDAs that shouldn't have ATAs, potentially causing fund loss or stuck tokens? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Maker native ATA] At lines 104-107, makerNativeAta is derived only when srcMint == NATIVE_MINT - if this ATA doesn't exist, does the SystemProgram.transfer() at lines 109-114 fail or create it incorrectly? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Sensitive data leakage] At line 86, the full order config including potentially sensitive data is written to 'order.json' - can an attacker access this file to front-run orders or extract private order details? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [File permission vulnerability] The fs.writeFileSync() at line 86 writes to 'order.json' with default permissions - can this file be read by other users on the system, leaking order information? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [File overwrite attack] At line 86, 'order.json' is written without checking if it exists - can an attacker cause important previous order data to be overwritten, leading to loss of order tracking information? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Console log exposure] At line 79, the order hash is logged to console as hex - in production environments, can this leak sensitive order identifiers that could be exploited? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Keypair path traversal] At line 146, makerKeypairPath is read from user input without sanitization - can an attacker use path traversal (../) to access arbitrary keypair files outside intended directories? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Public key injection] At lines 147-148, srcMint and dstMint are constructed from user input without validation - can an attacker provide invalid public keys causing transaction failures or exploitation? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Amount parsing vulnerability] At lines 149-150, amounts are parsed as Number() without validation - can negative numbers, NaN, or Infinity values cause unexpected behavior or crashes? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Order ID injection] At line 151, orderId is parsed as Number() from user input - can special values (negative, float, extremely large) cause the order creation to behave unexpectedly? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Keypair loading vulnerability] At line 156, loadKeypairFromFile() is called with unsanitized path - can this be exploited to load malicious keypairs or cause path traversal attacks? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [RPC endpoint manipulation] At line 145, clusterUrl is obtained from environment variable - can an attacker manipulate CLUSTER_URL to point to a malicious RPC that returns false confirmations? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Confirmation level risk] At line 153, the connection uses 'confirmed' commitment - can this cause race conditions where the order is considered created but the escrow isn't actually funded on-chain? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Transaction confirmation] At lines 136-138, sendAndConfirmTransaction() is used - if this times out or fails after the transaction is submitted, can it result in tokens being stuck in escrow without a valid order record? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Escrow PDA predictability] At lines 89-93, the escrow address is deterministically derived from maker and orderHash - can an attacker precompute escrow addresses to execute front-running or griefing attacks? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Escrow reuse attack] If a maker cancels an order and creates a new one with the same parameters, will the escrow PDA at lines 89-93 be the same, allowing potential exploitation of residual state? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Cross-maker escrow] Can two different makers craft orders that result in the same escrow PDA at lines 89-93, causing one maker's funds to be accessible by another maker's order? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Missing account validation] At lines 119-132, accounts are passed to the create instruction using accountsPartial() - are all required accounts properly validated by the program, or can missing accounts cause exploits? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Account substitution] Since accountsPartial() is used at line 121, can an attacker provide malicious accounts for optional fields to bypass security checks in the on-chain program? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Maker verification] At line 122, maker is set to makerKeypair.publicKey and listed as signer at line 131 - if the signer is not actually the maker, can this cause ownership issues for the escrow? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Amount relationship validation] At lines 36-37, srcAmount and minDstAmount are accepted without checking their relationship - can a maker set minDstAmount > fair market value * srcAmount to create unfillable orders that lock tokens? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Zero amount orders] Can srcAmount or minDstAmount be zero at lines 36-37, allowing creation of orders that could be exploited to drain fees or manipulate protocol metrics? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Amount proportion attack] If srcAmount is very small but minDstAmount is very large at lines 36-37, can this cause precision loss in price calculations that could be exploited during fills? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Mint equality check] At lines 38-39, srcMint and dstMint are accepted without checking if they're equal - can a maker create same-token swaps to exploit fee mechanisms or cause unexpected behavior? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Mint existence validation] At lines 158-159, getTokenDecimals() is called on srcMint and dstMint - if these mints don't exist on-chain, will the function fail gracefully or can it cause unexpected states? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Fake mint attack] Can an attacker provide fake or malicious mint addresses at lines 38-39 that pass initial validation but cause issues during token transfers? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [BN constructor overflow] At lines 165-166, new BN() is called with potentially very large numbers from Math.pow() - can this overflow or create incorrect BN values? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [BN precision loss] When BN values are used throughout the create function (lines 36-37, 48), are there any .toNumber() calls that could lose precision for amounts > 2^53? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [BN comparison issues] If BN amounts at lines 36-37, 48 need to be compared, are proper BN comparison methods used or could JavaScript number comparison cause bugs? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Config mismatch] At lines 53-76, reducedOrderConfig and orderConfig are created separately - can discrepancies between these cause the saved order.json to differ from what's submitted on-chain? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Partial config exploit] The reducedOrderConfig at lines 53-64 is passed to the program at line 120, while the full orderConfig at lines 66-76 includes additional fields - can this mismatch be exploited? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Fee config spreading] At lines 71-75, the fee object spreads the reduced fee then adds additional fields - can this cause field collision or overwriting that changes fee behavior? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Return value usage] At line 141, the function returns [escrow, escrowAta], and at lines 161-170 these are received but only logged - are there scenarios where incorrect return values could be used by callers without validation? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Escrow address verification] The returned escrow and escrowAta at line 141 are computed off-chain - can these differ from actual on-chain PDAs if the program's derivation logic differs? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Program ID trust] At lines 34, 90, the program's programId is used for PDA derivation - if the program object is initialized with wrong programId, can this cause all orders to have incorrect escrow addresses? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [IDL mismatch] At line 154, the program is created from FUSION_IDL - if this IDL doesn't match the deployed program, can instruction encoding cause funds to be locked or stolen? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Unhandled async errors] Throughout the create function (lines 32-142), multiple async operations occur - are all potential errors properly caught, or can unhandled rejections cause funds to be stuck? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Try-catch absence] The main function at lines 144-176 has no try-catch wrapper - can uncaught errors cause the process to crash with user funds in inconsistent state? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [getAssociatedTokenAddress failure] At lines 94-98 and 104-107, getAssociatedTokenAddress() is called - if this fails (e.g., due to network issues), are funds at risk? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Instruction parameters] At lines 119-132, the create instruction is built with specific accounts and signers - can the .instruction() method fail silently, causing incorrect instruction data to be sent? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Method chaining risk] The instruction builder at lines 119-132 uses method chaining - if any intermediate method fails, can this cause incorrect instruction construction without throwing an error? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Buffer conversion consistency] At line 92, orderHash is passed as Buffer.from(orderHash) but orderHash is already Uint8Array from calculateOrderHash() - can this double conversion cause data corruption? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Hash length validation] The orderHash returned at line 78 should be 32 bytes - is there validation before using it for PDA derivation at lines 89-93, or can invalid length hashes cause escrow derivation failures? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Signature verification] At line 136-139, the transaction signature is logged but not validated - can a malicious RPC return a fake signature while not actually processing the transaction? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Transaction confirmation race] Between getting the signature at line 136 and returning at line 141, is there risk that the transaction is confirmed but then dropped due to network issues? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [defaultFeeConfig manipulation] At line 45, fee defaults to defaultFeeConfig from utils - if this default has been maliciously modified in the imported utils module, can all orders created have incorrect fees? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [defaultAuctionData exploitation] At line 49, dutchAuctionData defaults to defaultAuctionData with far-future startTime - can this cause orders to be unfillable until the far future, locking maker funds? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [defaultExpirationTime consistency] At line 41, expirationTime defaults to defaultExpirationTime() which is now + 1 day - if the maker's clock is skewed, can orders be created with incorrect expiration? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Config serialization mismatch] The reducedOrderConfig at lines 53-64 is serialized into order hash at line 78 and also sent to program at line 120 - can discrepancies in serialization cause the program to reject orders with valid hashes? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Account list completeness] The accountsPartial() call at line 121 provides specific accounts, but are all accounts required by the IDL included, or can missing optional accounts cause unexpected behavior? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Decimal overflow] At lines 165-166, Math.pow(10, decimals) is used - for very high decimal values (e.g., 100), can this produce Infinity, causing incorrect amount calculations? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Decimal mismatch] If the fetched decimals at lines 158-159 don't match what the token actually uses on-chain, can this cause the order to have wildly incorrect amounts? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Zero decimal handling] Can tokens with 0 decimals at lines 158-159 cause the Math.pow(10, 0) to return 1, and if so, does this correctly handle integer token amounts? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [ATA initialization assumption] At lines 94-98, escrowAta is derived but not explicitly created - does the on-chain program handle ATA creation, or will the token transfer fail if the ATA doesn't exist? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Maker ATA existence] For SOL wrapping at lines 104-107, is the maker's native ATA created if it doesn't exist, or will the transfer at line 109-114 fail? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Number type parameters] Several parameters (orderId at line 40, expirationTime at line 41, cancellationAuctionDuration at line 50) are typed as number but should be u32 - can values > u32::MAX cause overflow in the program? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Boolean flag safety] The srcAssetIsNative and dstAssetIsNative flags at lines 43-44 are booleans - can these be manipulated via prototype pollution or type coercion to have unexpected values? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [JSON serialization attack] At line 86, JSON.stringify() is used - can circular references or specially crafted objects in orderConfigs cause stringification to fail or produce incorrect data? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [BN JSON serialization] The orderConfigs at line 84 contain BN types - does JSON.stringify() correctly serialize these, or will they be lost/corrupted in the saved file? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [SPL token version] At line 51, TOKEN_PROGRAM_ID is used by default - if the actual token uses Token-2022 with transfer fees or other extensions, can this cause incorrect escrow accounting? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Token program validation] The srcTokenProgram at line 127 is passed to the create instruction - does the on-chain program validate this is a legitimate token program, or can a malicious program be substituted? (Critical)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Funding source validation] The create instruction at lines 119-132 doesn't explicitly show the token transfer from maker to escrow - is this handled within the program, and can the funding be front-run or manipulated? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Maker balance check] Before creating the order, is the maker's balance of srcMint checked to ensure they have sufficient tokens, or can orders be created with insufficient funds? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Required fields validation] The reducedOrderConfig at lines 53-64 and orderConfig at lines 66-76 contain multiple fields - are all required fields present and validated, or can missing fields cause undefined behavior? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Field type consistency] Do all fields in the order configs have types that match the on-chain program's expectations, or can type mismatches cause deserialization errors? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Auction points manipulation] The dutchAuctionData at line 49 includes pointsAndTimeDeltas array - can a maker provide empty array, single point, or malformed points to break auction price calculations? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Rate bump overflow] If the auction points include rate bumps that sum to > u16::MAX in dutchAuctionData at line 49, can this cause overflow in on-chain price calculations? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Rent exemption handling] When wrapping SOL at lines 109-114, is rent exemption for the native ATA considered, or can the maker transfer insufficient lamports causing the ATA to be rent-collected? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [SOL balance after wrap] After the SOL wrap at lines 109-116, does the maker's regular SOL balance have enough for transaction fees, or can they become unable to cancel the order later? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Verbose logging risk] At lines 79, 87, and 139, sensitive information is logged - in production, can these logs be captured by attackers to track orders before they're filled? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Address logging] At lines 172-173, escrow addresses are logged - can this information be used to monitor and front-run order fills? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [CLUSTER_URL injection] At line 145, CLUSTER_URL environment variable is used - can an attacker manipulate this via environment to redirect all transactions to malicious endpoints? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [User prompt injection] At lines 146-151, prompt() is used for user input without sanitization - can malicious input cause command injection, path traversal, or other security issues? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Prompt library safety] The prompt-sync library at line 30 is used for input - are there known vulnerabilities in this library that could be exploited? (Low)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Empty transaction] If srcMint is not NATIVE_MINT at line 102, the transaction at line 100 starts empty - can an attacker cause the create instruction to be the only instruction, potentially allowing race conditions? (Medium)",
  "[File: scripts/fusion-swap/create.ts] [Function: create()] [Instruction ordering dependency] The SOL wrap instructions at lines 109-116 must complete before create at line 134 - if instruction ordering is not enforced, can funds be at risk? (High)",
  "[File: scripts/fusion-swap/create.ts] [Function: main()] [Keypair file security] At line 156, the keypair is loaded from filesystem - if this file is compromised or modified during execution, can orders be created with attacker-controlled makers? (\n\n### Citations\n\n**File:** scripts/fusion-swap/create.ts (L1-176)\n```typescript\nimport {\n  Connection,\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  sendAndConfirmTransaction,\n} from",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Order hash collision] Can an attacker craft two different OrderConfig structures that produce the same calculateOrderHash() output at line 39, allowing them to fill a different order than intended and steal tokens from an unrelated escrow? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Hash manipulation] Does the calculateOrderHash() call at line 39 properly validate all orderConfig fields before hashing, or can an attacker manipulate the hash by injecting malformed data structures to target arbitrary escrow accounts? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Hash collision attack] Can an attacker exploit the order hash calculation at line 127 by crafting orderConfig with specific field values that collide with existing escrow PDAs, enabling unauthorized access to other users' escrowed funds? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Hash preimage attack] Can a malicious resolver analyze the calculateOrderHash() implementation to generate preimages that match existing escrow addresses, allowing them to drain funds from arbitrary orders? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [PDA collision] Can an attacker manipulate the maker address and orderHash Buffer at lines 41-45 to generate a colliding escrow PDA that matches a different user's escrow, enabling cross-order token theft? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [PDA seed manipulation] Does the findEscrowAddress() call at lines 41-45 properly validate the Buffer.from(orderHash) conversion, or can an attacker inject malformed buffers to derive unauthorized escrow PDAs? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Resolver access bypass] Can an attacker exploit the findResolverAccessAddress() call at lines 52-55 by providing a different whitelistProgramId to bypass whitelist validation and fill orders without authorization? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Escrow PDA collision] Can the findEscrowAddress() call at lines 129-133 be exploited with manipulated maker/orderHash values to access escrows belonging to other users, enabling fund theft? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [PDA authority bypass] Can an attacker craft a fake orderHash that derives an escrow PDA controlled by their own program, allowing them to drain the escrow without proper authorization? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Integer overflow] Can the amount multiplication at line 68 (amount * Math.pow(10, srcMintDecimals)) overflow for large amount values, causing incorrect token transfers or complete transaction failure? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Decimal precision loss] Does the Math.pow(10, srcMintDecimals) calculation at line 68 handle edge cases where srcMintDecimals is 0 or extremely large (>18), potentially causing precision loss or overflow in amount calculation? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Amount underflow] Can a malicious resolver provide a very small amount value that, after decimal conversion at line 68, becomes 0 due to rounding, allowing them to extract src tokens without paying any dst tokens? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [User input overflow] Can the Number(prompt()) conversion at line 120 overflow or produce NaN for extremely large inputs, leading to undefined behavior in the subsequent fill() call? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [BN conversion attack] Can the new BN(amount * Math.pow(10, srcMintDecimals)) at line 68 produce incorrect values if the JavaScript number loses precision before BN conversion, enabling partial token theft? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Negative amount bypass] Does the amount parameter validation prevent negative values? Can an attacker pass a negative amount that becomes a large positive value after type coercion, draining the entire escrow? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Zero amount exploit] Can a resolver call fill() with amount=0 to trigger escrow closure logic without transferring any tokens, potentially locking or stealing escrowed funds? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [ATA ownership bypass] Can an attacker provide a malicious srcMint at line 47 to derive an escrowSrcAta that they control, allowing them to receive tokens from the fill operation instead of the legitimate taker? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Fake mint attack] Does the getAssociatedTokenAddress() call at lines 46-50 validate that orderConfig.srcMint is a legitimate token mint, or can an attacker use a fake mint to bypass token transfer validations? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [ATA collision] Can the getAssociatedTokenAddress() calls at lines 46-50 and 57-60 produce colliding ATAs for different mints, enabling token theft through account confusion? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Taker ATA manipulation] Can a malicious resolver provide a takerKeypair that owns a takerSrcAta for a different mint, causing the fill instruction to transfer tokens to the wrong account? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Escrow ATA validation bypass] Does the escrow existence check at lines 141-148 properly validate that the escrowSrcAtaAddr belongs to the correct escrow PDA, or can an attacker fake this check with a different ATA? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Mint decimals manipulation] Can an attacker deploy a malicious token mint with incorrect decimals that causes getTokenDecimals() at lines 62-65 to return manipulated values, leading to incorrect amount calculations? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Decimals overflow] If srcMintDecimals returned at line 62-65 is extremely large (>30), can it cause overflow in Math.pow(10, srcMintDecimals) at line 68, resulting in Infinity or incorrect amount calculation? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [RPC manipulation] Can a compromised RPC node return fake token decimals in getTokenDecimals() at lines 62-65, causing the resolver to send incorrect amounts and lose funds? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Missing decimals validation] Does the code validate that srcMintDecimals is within reasonable bounds (0-18)? Can values outside this range cause calculation errors or security issues? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Maker validation bypass] Can an attacker provide an arbitrary maker address at line 34 that doesn't match the actual order creator, allowing them to drain escrows created by other users? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Receiver manipulation] Does the code validate that orderConfig.receiver matches the intended recipient, or can an attacker modify this field to redirect tokens to their own address? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Protocol fee account hijack] Can a malicious resolver manipulate orderConfig.fee.protocolDstAcc at line 79 to redirect protocol fees to their own account instead of the protocol treasury? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Integrator fee hijack] Can an attacker modify orderConfig.fee.integratorDstAcc at line 80 to steal integrator fees by redirecting them to an attacker-controlled account? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Missing escrow ownership check] Does the fill() function verify that the derived escrow PDA at lines 41-45 is owned by the fusion_swap program before attempting to fill, preventing cross-program exploits? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Maker address spoofing] Can an attacker provide a fake maker public key at line 98 to check for orders belonging to other users and subsequently fill them with manipulated parameters? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [OrderConfig injection] Can an attacker craft a malicious JSON file at line 100 that, when parsed, contains executable code or causes the script to load unintended order configurations? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [BN hex manipulation] Can the BN constructor calls with 'hex' encoding at lines 104-106 be exploited with malformed hex strings to produce incorrect amounts or cause crashes? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [PublicKey injection] Can the new PublicKey() calls at lines 107-109 be exploited with invalid base58 strings to cause transaction failures or unexpected behavior? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [ReducedOrderConfig mismatch] Can an attacker provide a reducedOrderConfig at lines 111-116 that doesn't match the full orderConfig, causing hash mismatches and enabling order substitution attacks? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Mint mismatch attack] Can an attacker modify orderConfig.srcMint and orderConfig.dstMint at lines 107-108 to differ from the reducedOrderConfig, bypassing validation and stealing tokens? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Amount overflow in config] Can the BN conversions at lines 104-106 and 113-115 overflow when parsing extremely large hex values from the JSON file, causing incorrect order amounts? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Receiver substitution] Can an attacker modify orderConfig.receiver at line 109 without affecting the reducedOrderConfig, causing the fill to send tokens to an unintended recipient? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Path traversal] Can an attacker exploit the orderFilePath prompt at line 97 with '../' sequences to read arbitrary JSON files from the file system, leaking sensitive configuration data? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [JSON injection] Can the fs.readFileSync() call at line 100 be exploited if an attacker controls the file path, allowing them to inject malicious JSON that modifies program behavior? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Keypair theft] Can the takerKeypairPath prompt at line 118 be exploited to read keypair files from unintended locations, potentially exposing private keys? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Prompt injection] Can an attacker inject malicious input through the prompt() calls at lines 97, 98, 118, 120 to cause command injection or unexpected script behavior? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Missing input sanitization] Are the user inputs from prompt() calls properly sanitized before use? Can special characters or escape sequences cause security issues? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Missing signer validation] Does the fillIx instruction at lines 67-85 properly validate that takerKeypair is the actual signer, or can an attacker substitute a different signer mid-execution? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Account reordering attack] Can an attacker reorder the accounts in accountsPartial at lines 69-83 to cause the on-chain program to use incorrect account references, enabling token theft? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Missing account writable flags] Does the instruction properly set writable flags for accounts that should be mutated? Can missing flags cause transaction failures or enable exploits? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Token program substitution] Can an attacker provide malicious TOKEN_PROGRAM_ID values at lines 81-82 to redirect token transfers to a fake program that doesn't enforce transfer rules? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Instruction data manipulation] Can the reducedOrderConfig parameter at line 68 be manipulated independently of the orderConfig used for hash calculation, causing order/escrow mismatch? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Transaction malleability] Can an attacker modify the transaction at line 87 after it's built but before signing to inject additional instructions that steal funds? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Partial signature bypass] Does the signers array at line 84 include all required signers, or can an attacker exploit missing signers to bypass authorization checks? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Transaction replay] Is there any replay protection for the fill transaction at lines 89-91? Can an attacker replay a successful fill transaction to drain more tokens? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Program ID substitution] Can an attacker provide a malicious program.programId at line 42 to derive PDAs for a fake fusion_swap program, enabling them to control the escrow logic? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Whitelist program bypass] Can the whitelistProgramId parameter at lines 32, 53 be substituted with a fake whitelist program that always validates any resolver, bypassing access control? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Fusion program swap] Can an attacker modify the fusionSwap program initialization at line 123 to point to a malicious program that steals funds during fill execution? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Whitelist program substitution] Can the whitelist program at line 124 be replaced with a fake implementation that approves unauthorized resolvers? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Cross-program exploitation] Can a malicious resolver exploit the interaction between the fill instruction and the whitelist program to bypass resolver access checks? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Silent error handling] Does the try-catch block at lines 126-148 properly handle all error types, or can certain errors be suppressed allowing invalid orders to be processed? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Escrow existence bypass] Can the escrow existence check at line 141 be fooled by a fake ATA that appears valid but doesn't actually hold the correct escrow tokens? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [RPC failure exploitation] If the connection.getAccount() or similar RPC calls fail, can this lead to incorrect state assumptions that enable exploits? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Async race condition] Can concurrent calls to fill() for the same order create race conditions that allow double-filling or partial fills that violate escrow invariants? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Missing validation on error] If splToken.getAccount() at line 141 succeeds but returns an account with 0 balance, does the script still proceed with the fill, causing guaranteed transaction failure? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Config mismatch] Can an attacker provide a reducedOrderConfig that has different amounts than the full orderConfig, causing the on-chain program to process amounts that don't match the escrow? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Reduced config manipulation] Can the reducedOrderConfig parsing at lines 111-116 be manipulated to contain amounts that differ from the full config, enabling amount mismatch exploits? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Fee config omission] If reducedOrderConfig doesn't include fee parameters but full orderConfig does, can this discrepancy be exploited to bypass fee payments? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Auction data mismatch] Can differences in dutchAuctionData between reducedOrderConfig and full orderConfig cause the on-chain program to calculate incorrect exchange rates? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [RPC endpoint manipulation] Can an attacker control the CLUSTER_URL environment variable to redirect all RPC calls to a malicious node that provides fake blockchain state? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Connection downgrade] Does the 'confirmed' commitment level at line 122 provide sufficient finality guarantees, or can an attacker exploit forks to reverse filled orders? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Stale data exploitation] Can an attacker exploit timing between getTokenDecimals() at lines 62-65 and transaction submission to use outdated decimal values? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [RPC censorship] Can a malicious RPC provider censor fill transactions for specific orders, enabling the provider to fill orders with their own resolver for profit? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Native SOL confusion] If orderConfig.srcAssetIsNative is true but the script doesn't handle native SOL specially, can this cause the fill to fail or enable SOL theft? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [WSOL wrapping bypass] Does the script properly handle wrapped SOL (WSOL) token addresses? Can an attacker exploit WSOL/SOL confusion to drain native SOL from escrows? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Native SOL ATA creation] Can the getAssociatedTokenAddress() calls at lines 46-50, 57-60 fail or produce incorrect addresses for native SOL mints, causing transaction failures? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [ATA initialization race] If takerSrcAta doesn't exist yet, can a race condition allow an attacker to initialize it with incorrect parameters before the fill transaction executes? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [allowOwnerOffCurve bypass] Does the getAssociatedTokenAddress() call with allowOwnerOffCurve=true at lines 46-50 create security risks by allowing PDAs with off-curve public keys? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Missing ATA existence check] Does the script verify that takerSrcAta exists before building the transaction? Can a non-existent ATA cause transaction failure or enable exploits? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Null fee account exploit] If orderConfig.fee.protocolDstAcc is null when it should exist, can this cause the on-chain program to skip fee collection or fail in an exploitable way? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Fee account ownership] Does the script validate that protocolDstAcc and integratorDstAcc at lines 79-80 are owned by the correct entities, preventing fee redirect attacks? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Fee account type mismatch] Can an attacker provide native SOL accounts as fee destinations when token ATAs are expected, causing transaction failures or fund locks? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Resolver access PDA manipulation] Can the findResolverAccessAddress() call at lines 52-55 be exploited to derive a PDA that bypasses the whitelist check on-chain? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Resolver key substitution] Can an attacker substitute takerKeypair.publicKey at line 54 with a different key to use someone else's resolver access authorization? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Missing resolver validation] Does the script verify that takerKeypair has valid resolver access before attempting the fill, or does it rely solely on on-chain validation? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Excessive fill amount] Can a resolver specify an amount at line 120 that exceeds the remaining escrow balance, causing the transaction to fail or enabling partial exploits? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Minimum fill bypass] Does the code enforce any minimum fill amount? Can a resolver fill with dust amounts to grief makers by fragmenting their orders? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Fill amount precision] Can floating-point precision issues in the amount parameter at line 36 cause rounding errors that enable small-scale fund theft over many fills? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Fake escrow detection] Does the escrow existence check at lines 135-141 verify that the escrow is properly initialized and contains the correct token amount, or just that an account exists? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Escrow ATA ownership] Can the getAccount() call at line 141 be satisfied by an ATA that isn't actually owned by the escrow PDA, enabling fake escrow attacks? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Closed escrow exploitation] Can an attacker fill an order after the escrow has been closed but before the transaction is finalized, causing the on-chain program to error in an exploitable way? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Auction timing attack] Can a resolver manipulate transaction timing to fill orders at favorable auction prices by delaying or rushing transaction submission? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Timestamp manipulation] Can the resolver exploit block timestamp variability to get better prices than they should receive based on the intended auction curve? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Rate bump exploitation] If dutchAuctionData contains extreme rate bump values, can this cause overflow in the on-chain program's rate calculations, leading to incorrect pricing? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Instruction injection] Can an attacker inject additional instructions into the transaction at line 87 that execute before or after the fill instruction to manipulate state? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Missing compute budget] Does the transaction include sufficient compute budget? Can complex orders cause compute exhaustion, enabling DoS attacks? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Priority fee manipulation] Can a malicious resolver manipulate transaction priority fees to ensure their fills are processed before honest resolvers, gaining unfair auction advantages? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Import validation] [Type confusion] Can type mismatches between the imported FUSION_IDL at line 12 and the actual deployed program cause the script to build invalid transactions? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Import validation] [IDL version mismatch] If the IDL at line 12 is outdated compared to the deployed program, can this cause instruction data serialization errors that enable exploits? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Import validation] [Whitelist IDL substitution] Can an attacker replace WHITELIST_IDL at line 13 with a malicious IDL that causes incorrect resolver access validation? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Partial fill griefing] Can a malicious resolver repeatedly fill orders with tiny amounts to fragment escrows and make them economically unviable to fully fill? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Fill race condition] Can multiple resolvers race to fill the same order, causing some transactions to fail and wasting gas, or enabling partial exploitation? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Remainder exploitation] After a partial fill, can the remaining escrow balance be exploited due to rounding errors or state inconsistencies? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Receiver validation bypass] Can the makerReceiver account at line 73 be an arbitrary address different from the intended maker, enabling token theft by redirecting fills? (Critical)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Receiver account type] Does the script validate that makerReceiver is the correct account type (ATA vs native account)? Can type confusion cause fund loss? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Confirmation bypass] Does sendAndConfirmTransaction at lines 89-91 properly wait for confirmation, or can an attacker exploit premature success reporting to execute double-fills? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Transaction failure handling] If the fill transaction fails on-chain but the script doesn't detect it, can this lead to incorrect state assumptions in subsequent operations? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Signature verification] Does the script verify the transaction signature is valid and matches the expected signer, preventing transaction substitution attacks? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Order batch exploitation] Can an attacker create a script to fill multiple orders in a single transaction, exploiting atomic execution to sandwich or front-run other resolvers? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Cross-order state manipulation] Can filling one order affect the state of other orders in ways that enable cross-order exploits or fund theft? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Mint authority exploit] Can an attacker who controls mint authority for srcMint or dstMint manipulate token supply during the fill to cause imbalanced exchanges? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Freeze authority abuse] If the token mint has freeze authority, can it be used to freeze taker accounts mid-fill, causing transaction failures that benefit the attacker? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Mint decimals manipulation] Can a malicious token mint report incorrect decimals at line 62-65, causing the fill amount to be calculated incorrectly? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Token program version] Does the script validate that TOKEN_PROGRAM_ID at lines 81-82 is the correct SPL Token program version, preventing exploits from using outdated program versions? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Token 2022 incompatibility] If tokens use Token-2022 program extensions, can incompatibilities cause the fill to fail or enable exploits through extension manipulation? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Expired order fill] Does the script check orderConfig.expirationTime before attempting to fill, or does it rely solely on on-chain validation that could be bypassed? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Timestamp manipulation] Can clock drift or timestamp manipulation cause expired orders to be fillable, or valid orders to be rejected? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [JSON parsing exploit] Can the JSON.parse() call at line 100 be exploited with maliciously crafted JSON to cause prototype pollution or code execution? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Hex encoding manipulation] Can the hex encoding used in BN conversions at lines 104-106, 113-115 be manipulated to cause incorrect value parsing? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Buffer overflow in hash] Can the Buffer.from(orderHash) conversion at line 132 overflow or produce incorrect buffers if orderHash contains invalid data? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Unauthorized fill] Can someone other than an authorized resolver execute this script with a valid keypair to fill orders they shouldn't be able to fill? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Keypair theft risk] Does the loadKeypairFromFile() call at line 119 expose the private key in memory in ways that could enable theft by other processes? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Signer substitution] Can the signers array at line 84 be manipulated to include different signers than intended, bypassing authorization? (High)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [State race condition] Between the time escrow PDAs are derived (lines 41-45) and the transaction executes (line 89), can state changes cause the transaction to execute with stale data? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Order state validation] Does the script verify that the order is in a fillable state (not cancelled, not fully filled), or can stale orders be processed? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Program upgrade exploitation] If the fusion_swap program is upgraded between when the IDL is loaded (line 12) and when the transaction executes, can this cause instruction data mismatches? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Instruction layout change] Can changes to the fill instruction's expected account layout cause the accountsPartial at lines 69-83 to map accounts incorrectly? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [MEV extraction] Can a malicious resolver or validator reorder, front-run, or sandwich the fill transaction to extract MEV at the expense of makers or other resolvers? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Gas price manipulation] Can a resolver manipulate gas prices to ensure their fills execute before competing resolvers, gaining unfair advantages in the auction? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Fee optimization exploit] Can a resolver structure their fill to minimize fees paid while still satisfying the order, effectively stealing from protocol fee revenue? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Environment variable injection] Can the getClusterUrlEnv() call at line 96 be exploited by injecting malicious environment variables to redirect RPC calls? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Config file path traversal] Can the orderFilePath input at line 97 use '../' or absolute paths to read sensitive configuration files from the system? (Medium)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Account size limits] Can extremely large orderConfig structures cause the transaction to exceed account size limits, causing failures or exploitable error states? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Compute unit exhaustion] Can complex orderConfig with many dutchAuctionData points cause on-chain compute exhaustion, enabling DoS against specific orders? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Memory exhaustion] Can loading extremely large order configuration files at line 100 cause the script to exhaust memory and crash? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Transaction size limits] Can the fill instruction with all accounts at lines 69-83 exceed transaction size limits for certain order configurations? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: main()] [Concurrent execution] Can multiple instances of this script running concurrently cause race conditions or state inconsistencies? (Low)",
  "[File: scripts/fusion-swap/fill.ts] [Function: fill()] [Reentrance vulnerability] Can the fill operation be exploited through reentrance if any of the accounts involved have malicious programs as owners? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Input validation] Can an attacker provide a malformed orderHash string (e.g., odd-length hex, invalid characters, or non-hex values) at line 29 that causes parseInt() to return NaN values, resulting in incorrect PDA derivation and potential cancellation of a different user's order? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [PDA collision] If the orderHash regex match at line 29 returns null or an empty array, can an attacker exploit the empty Array.from() result to derive a zero-byte order hash, potentially colliding with PDAs of legitimate orders and enabling unauthorized cancellations? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Integer overflow] When converting hex string to bytes via parseInt(h, 16) at line 30, can an attacker provide hex values exceeding 0xFF that get truncated, causing order hash mismatch and cancellation of unintended escrows? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Input injection] Can an attacker inject malicious input through prompt() at line 68 (order hash) containing control characters or escape sequences that manipulate downstream PDA derivation or transaction construction? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Type confusion] At line 69, if srcMint prompt receives an invalid public key string, can this cause PublicKey constructor to throw or create an invalid key that passes client-side checks but fails on-chain, leading to locked funds? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Boolean parsing] At line 71, the srcAssetIsNative boolean is parsed via string comparison with 'true' - can an attacker provide 'True', '1', or other truthy values that evaluate incorrectly, causing native/non-native mismatch and failed cancellations with lost gas fees? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Array mutation] After converting orderHash to bytes at line 29-31, if the orderHashBytes array is mutated before being used in findEscrowAddress at line 33, could this cause PDA derivation mismatch and cancellation failures? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Order hash format] Can an attacker provide orderHash without the '/../g' regex match pattern (e.g., single character, no pairs) causing the Array.from() at line 29 to produce an incorrect byte array length that passes validation but targets wrong escrow? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [PDA security] Does findEscrowAddress at line 33 properly validate that the derived escrow PDA is unique per maker+orderHash combination, or can an attacker craft collision inputs that derive PDAs for other users' escrows? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Seed manipulation] Can an attacker manipulate the orderHash parameter passed to findEscrowAddress at line 33 to include additional seed bytes that cause the PDA derivation to match an escrow belonging to a different maker, enabling cross-account cancellation attacks? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [PDA validation] At line 79, when deriving escrowAddr for validation, if an attacker provides a different orderHash format than expected by the on-chain program, can this cause the client to check existence of one PDA while canceling a different PDA? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Bump seed missing] The escrow PDA is derived at line 33 without explicitly handling bump seeds - can this cause non-deterministic PDA derivation if findEscrowAddress doesn't use the same bump as the on-chain program, leading to transaction failures and gas wastage? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Program ID mismatch] If program.programId at line 34 doesn't match the actual deployed fusion-swap program ID, can this cause derivation of incorrect escrow PDAs that pass client-side validation but fail on-chain, wasting transaction fees? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [TOCTOU race] Between checking escrow existence via getAccount at line 91 and calling cancel at line 100, can another transaction fill or cancel the order, causing the cancellation to fail but still consuming maker's transaction fees? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Account ownership] Does getAccount at line 91 validate that escrowSrcAtaAddr is actually owned by the Token Program and associated with the correct escrow PDA, or can an attacker create a fake account at that address that passes existence check but fails cancellation? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [ATA derivation] At line 39, getAssociatedTokenAddress derives the escrow's source ATA - can an attacker exploit the allowOwnerOffCurve=true parameter to create ATAs with manipulated seeds that pass client validation but don't match on-chain expectations? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Existence validation bypass] If getAccount throws at line 91 but the catch block at line 93 logs an error without halting, could execution continue to call cancel on a non-existent order, wasting gas and potentially causing unexpected on-chain behavior? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Token mint validation] Does the script validate that srcMint at line 49 matches the actual token mint stored in the escrow account, or can an attacker provide a wrong mint address that passes client checks but causes on-chain validation failure? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Account data verification] At line 91, getAccount retrieves the ATA but doesn't verify its amount, authority, or mint - can an attacker front-run and drain the escrow after existence check but before cancellation, causing the cancel to fail with unclear error messages? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Maker validation] Does the on-chain cancel instruction properly verify that makerKeypair at line 48 is the original order creator, or can an attacker who obtains any keypair matching the PDA derivation seeds cancel arbitrary orders? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Keypair security] At line 76, loadKeypairFromFile loads the maker's private key - if an attacker gains access to the file system, can they extract keypairs and cancel all orders from that maker, causing complete order book manipulation? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Signature validation] At line 54, the maker is added as a signer - but does the script validate that the signer matches the maker public key derived in the escrow PDA seeds at line 35, preventing signature substitution attacks? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Authority bypass] Can an attacker submit the cancel transaction with a different maker keypair than the one used for PDA derivation at line 35, causing the on-chain program to accept the cancellation from an unauthorized party? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Keypair path traversal] At line 67, makerKeypairPath is prompted from user input - can an attacker inject path traversal sequences (../../sensitive) to load keypairs from arbitrary file system locations, enabling unauthorized cancellations? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Instruction ordering] At line 57, the cancel instruction is added to a new transaction - can an attacker front-run this with a fill transaction that completes the order, causing the cancel to fail but still consume the maker's SOL for transaction fees? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Transaction malleability] Between instruction creation at line 45 and transaction submission at line 59, can an attacker modify the transaction object to inject additional instructions that drain the maker's account or manipulate the cancellation? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Compute budget] Does the transaction construction set appropriate compute unit limits, or can an attacker cause the cancel instruction to exceed compute limits and fail on-chain while still charging priority fees? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Fee manipulation] At line 59, sendAndConfirmTransaction uses default fee settings - can an attacker exploit fee markets to make cancellations economically unprofitable, effectively DoS-ing order cancellations during high network congestion? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Account list validation] Does the accountsPartial at line 47 properly validate that all required accounts are provided, or can missing accounts cause the instruction to pass client-side checks but fail on-chain with cryptic errors? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Partial account provision] Using accountsPartial at line 47 instead of accounts() - can this cause the Anchor framework to omit critical account validations, allowing malformed cancel instructions to pass client checks but fail unpredictably on-chain? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Native asset flag] At line 46, srcAssetIsNative is passed to the cancel instruction - if this flag doesn't match the on-chain order state, can an attacker cause the cancellation to attempt native SOL operations on wrapped SOL accounts, leading to failed unwrapping and locked funds? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Native/non-native mismatch] At line 71, srcAssetIsNative is determined by user input - if an attacker provides incorrect boolean value for a native SOL order (claiming false when true), can this cause the on-chain program to skip SOL unwrapping, leaving funds locked in the wrapped SOL ATA? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [SOL unwrap validation] When srcAssetIsNative is true, does the on-chain cancel instruction properly validate that the escrow_src_ata is a valid wSOL account before attempting to close it, or can an attacker trigger cancellation on non-wSOL accounts causing unexpected behavior? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Native mint validation] If srcMint at line 69 is the native mint (So11111...1112) but srcAssetIsNative at line 71 is false, can this inconsistency cause the cancel to fail validation on-chain, wasting gas fees? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [wSOL rent exemption] For native SOL cancellations, does the script account for the rent exemption minimum balance that must remain in the wSOL ATA, or can attempts to cancel native orders fail due to insufficient lamports for rent? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Partial fill handling] If the order has been partially filled before cancellation, does the cancel instruction properly return only the remaining tokens to the maker, or can an attacker exploit assumptions about full escrow balance to cause arithmetic errors? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Token recovery] When the on-chain cancel instruction executes, does it properly transfer all remaining tokens from escrow_src_ata back to maker_src_ata, or can rounding errors or improper amount calculations leave dust amounts locked in the escrow? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Account closure] After cancellation, does the on-chain program properly close the escrow_src_ata and return rent exemption lamports to the maker, or can attackers repeatedly cancel and recreate orders to drain the maker's SOL balance through rent costs? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Escrow authority] Does the on-chain cancel validate that the escrow PDA is the authority of escrow_src_ata before attempting token transfers, or can an attacker manipulate account ownership to redirect refunded tokens to their own account? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Zero balance cancellation] If getAccount at line 91 succeeds but the escrow ATA has zero token balance (already filled), can the cancellation still execute and waste transaction fees trying to transfer zero tokens? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Error handling] If getAccount throws at line 91, the catch block at line 93 logs but then returns early at line 97 - can this leave the order in an inconsistent state where the escrow exists but client believes it doesn't, causing future operation failures? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Transaction failure] If sendAndConfirmTransaction at line 59 fails due to slippage or network issues, does the script properly handle the error and inform the user, or can silent failures leave orders in limbo without clear status? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Validation error messages] At line 94-96, if the escrow doesn't exist, the error message logs both orderHash and maker pubkey - can information leakage in these logs expose sensitive order details that attackers can use for targeted manipulation? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Confirmation depth] At line 73, connection uses 'confirmed' commitment level - can this cause race conditions where the cancel appears successful but gets reorganized out during finalization, leaving the order in an unexpected state? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Signature verification] After sendAndConfirmTransaction returns at line 59, does the script verify that the transaction was actually successful on-chain, or can a failed transaction still return a signature, misleading the user about cancellation status? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Program ID validation] At line 34, program.programId is used for PDA derivation - if an attacker deploys a malicious program with similar interface and tricks users into connecting to it, can they steal tokens during fake cancellations? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Token program validation] At line 52, TOKEN_PROGRAM_ID is hardcoded to the standard SPL token program - can an attacker exploit Token-2022 or other token program variants that require different instruction formats, causing cancellation failures? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [IDL mismatch] At line 74, FUSION_IDL is loaded from a JSON file - if this IDL doesn't match the deployed program version, can instruction serialization errors cause malformed cancel instructions that fail on-chain? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Account meta flags] When building the instruction at line 45, does accountsPartial properly set writable/signer flags for all accounts, or can incorrect flags cause the on-chain program to reject valid cancellations? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [CPI depth] If the on-chain cancel instruction performs CPIs to the token program for token transfers and account closures, can deep CPI stacks cause the transaction to exceed the CPI depth limit and fail? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Order expiration] The script doesn't check if the order has expired before attempting cancellation - can an attacker front-run with cancel_by_resolver after expiration to capture cancellation premium before the maker can cancel for free? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Front-running] Between escrow existence check in main() at line 91 and cancel execution at line 100, can a malicious resolver front-run to fill the entire order, causing the cancel to fail and waste the maker's gas fees? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [MEV exploitation] Can MEV bots monitor mempool for cancel transactions and front-run to fill orders at the last possible moment, forcing makers to pay gas for failed cancellations repeatedly? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Slot dependency] At line 73, using 'confirmed' commitment without checking slot numbers - can transactions appear confirmed in one slot but get replaced in another, causing double-cancellation attempts or state inconsistencies? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Timestamp manipulation] The script doesn't validate current blockchain time against order expiration - can clock skew between client and chain cause cancellations to be submitted after expiration, missing the free cancellation window? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Environment variable injection] At line 66, getClusterUrlEnv reads CLUSTER_URL from environment - can an attacker manipulate this to point to a malicious RPC endpoint that returns fake account data, tricking users into failed cancellations? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [RPC endpoint trust] The connection at line 73 trusts the provided cluster URL - can a compromised RPC endpoint return manipulated account states that cause the script to build incorrect cancel instructions? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Prompt injection] At lines 67-71, all inputs are read via prompt() - can an attacker inject control sequences or escape characters that break terminal state and cause subsequent operations to fail silently? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Anchor version mismatch] The script uses @coral-xyz/anchor imports - if the Anchor version doesn't match the version used to build the on-chain program, can this cause instruction deserialization errors on-chain? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Utility function trust] At line 14, findEscrowAddress is imported from utils - if this function has bugs in PDA derivation logic, can all cancellations target wrong escrows, causing widespread order manipulation? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Order hash integrity] The orderHash passed at line 27 should match the hash computed by the on-chain program - can an attacker provide a valid-looking but incorrect hash that passes PDA derivation but targets a different order's escrow? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Hash collision] If two different orders produce the same orderHash due to hash collisions, can an attacker cancel one order by providing the hash of another, causing cross-order cancellation attacks? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Byte order] At line 29-31, the orderHash is converted from hex string to byte array - can incorrect byte ordering (big-endian vs little-endian) cause the PDA derivation to use reversed hash values, targeting wrong escrows? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Hash validation] The script doesn't validate that orderHash at line 68 is a valid 32-byte hex string before attempting conversion - can shorter/longer hashes cause buffer overflow or underflow in PDA derivation? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Seed concatenation] When deriving escrow PDA at line 33-36, are the seeds properly concatenated with correct separators, or can missing boundaries cause seed ambiguity where different (maker, orderHash) pairs produce the same PDA? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [ATA owner validation] At line 39-42, getAssociatedTokenAddress derives escrowSrcAta but doesn't verify the owner - can an attacker create a fake ATA at that address owned by themselves, causing token transfers to go to the wrong account? (Critical)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Mint authority] Does the script validate that srcMint has proper mint authority and isn't a fake token, or can an attacker create a malicious token mint that allows arbitrary minting during cancellation? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Token program validation] At line 52, TOKEN_PROGRAM_ID is used - but does the script verify this matches the token program that owns escrowSrcAta, or can mismatched programs cause CPI failures? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Delegate validation] If escrowSrcAta has a delegate set, can the on-chain cancel instruction properly revoke the delegation before closing the account, or can delegates retain control over tokens? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Close authority] When the escrow ATA is closed during cancellation, does the on-chain program validate that the escrow PDA is the close authority, preventing unauthorized account closures? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Gas griefing] Can an attacker repeatedly trigger failed cancellations by manipulating account states, causing the maker to waste SOL on transaction fees without successfully canceling the order? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Rent economics] At line 91, the script checks escrow existence but doesn't validate rent exemption status - can orders with insufficient rent be canceled, leaving the maker unable to recover rent exemption amounts? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Priority fee exploitation] The script doesn't set priority fees - during network congestion, can attackers prevent cancellations by forcing makers to compete with excessively high priority fees, making cancellations economically infeasible? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Fee payer validation] At line 59, the maker keypair pays transaction fees - if the maker's SOL balance is insufficient, can this cause cancellation failures that still deduct partial fees, draining the maker's account? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Compute unit exhaustion] The script doesn't specify compute unit limits - can complex cancel instructions with many CPI calls exceed default limits and fail after consuming fees? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Concurrent cancellation] If multiple instances of this script run concurrently with the same maker keypair, can they attempt to cancel the same order multiple times, causing nonce conflicts and transaction failures? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Instruction data size] Can extremely long order hashes or account lists cause the instruction data to exceed Solana's transaction size limits, resulting in failed transaction submission? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [File system race] At line 76, loadKeypairFromFile performs file I/O - can concurrent modifications to the keypair file cause partial reads that produce invalid keypairs, leading to signature verification failures? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Account reallocation] If the on-chain program reallocates account data during cancellation, can this cause the transaction to fail due to insufficient compute units or unexpected account size changes? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Unicode handling] If prompt inputs at lines 67-71 contain Unicode characters, can encoding issues cause public key parsing to fail or orderHash conversion to produce incorrect byte arrays? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Associated token program version] At line 42, getAssociatedTokenAddress uses allowOwnerOffCurve parameter - can mismatches between expected and actual PDA derivation cause the on-chain program to reject the provided ATA address? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Connection timeout] At line 73, no timeout is specified for the connection - can hanging RPC requests cause the script to block indefinitely, preventing cancellations during network issues? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Signer deduplication] At line 60, makerKeypair is added as signer - if the same keypair is referenced multiple times in the transaction, can this cause signature verification failures or wasted compute units? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Keypair format validation] At line 76, loadKeypairFromFile expects a specific JSON format - can malformed keypair files cause parsing errors that expose sensitive key material in error messages? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Recent blockhash] The transaction at line 57 doesn't explicitly set a recent blockhash - can stale blockhashes cause the transaction to be rejected after the maker has committed to cancellation? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Whitelist bypass] The cancel function doesn't check whitelist status - if the on-chain program allows only whitelisted resolvers to cancel after expiration, can makers cancel before expiration to avoid paying cancellation premiums they should owe? (Medium)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Program upgrade] If the fusion-swap program is upgraded between escrow existence check at line 91 and cancellation at line 100, can instruction format changes cause the cancel to fail with cryptic errors? (Low)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Cross-account validation] Does the on-chain cancel instruction validate that maker, escrow, and escrowSrcAta all belong to the same order, or can an attacker mix accounts from different orders to manipulate cancellation logic? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: cancel()] [Account discriminator] Does the on-chain program validate account discriminators to ensure escrow is the expected account type, or can attackers pass arbitrary accounts that satisfy PDA derivation but have wrong data layouts? (High)",
  "[File: scripts/fusion-swap/cancel.ts] [Function: main()] [Program state validation] The script doesn't check if the fusion-swap program is paused or in maintenance mode - can cancellations be submitted when the program is not accepting transactions, wasting gas fees? (Low)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [PDA Collision] Can an attacker manipulate the orderHash parameter by providing a maliciously crafted string that, when converted to Buffer via the hex parsing logic (lines 96-99), produces the same PDA as another legitimate order, allowing escrow account collision and potential fund theft? (Critical)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [Input Validation] Does the hex string parsing logic (lines 96-99) properly validate that orderHash contains only valid hexadecimal characters, or can an attacker inject non-hex characters that get silently converted to unexpected bytes, leading to PDA derivation manipulation? (High)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [Type Confusion] Can an attacker exploit the dual type acceptance (Buffer | string) for orderHash to cause inconsistent PDA derivation between different invocations, potentially creating multiple escrow accounts for the same order or accessing wrong escrow accounts? (High)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [Buffer Length] Does the function validate the length of the orderHash buffer after conversion, or can an attacker provide a truncated or oversized hash that still passes through but derives an incorrect PDA, enabling escrow manipulation? (High)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [Regex Vulnerability] Can the regex pattern (/../g) on line 96 be exploited with specially crafted strings that cause unexpected matching behavior, leading to incorrect buffer construction and PDA collision attacks? (Medium)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [Seed Order] Does the PDA seed construction (lines 104-106) maintain consistent ordering of [escrow, maker, orderHash] across all protocol calls, or can seed order manipulation in other parts of the codebase lead to different PDAs being derived for the same logical escrow? (High)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [Empty Hash] Can an attacker pass an empty string for orderHash that results in an empty buffer, causing the PDA to be derived from only the 'escrow' seed and maker pubkey, potentially allowing collision with other orders from the same maker? (Critical)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [Null/Undefined] Does the function handle null or undefined orderHash inputs, or can passing these values cause unexpected behavior that leads to default PDA derivation and potential escrow access control bypass? (High)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [Case Sensitivity] If orderHash is provided as a hex string, can an attacker exploit case sensitivity differences (uppercase vs lowercase hex) to generate different buffers for the same logical hash, creating PDA collisions? (Medium)",
  "[File: scripts/utils.ts] [Function: findEscrowAddress()] [Odd-Length Hex] Can an attacker provide an odd-length hexadecimal string that causes the regex matching on line 96 to produce unexpected results, potentially truncating or padding the hash and leading to PDA manipulation? (High)",
  "[File: scripts/utils.ts] [Function: findResolverAccessAddress()] [Seed Uniqueness] Does the PDA derivation using only 'resolver_access' prefix and user pubkey (lines 119-120) ensure sufficient uniqueness, or can the same PDA be derived for multiple logical resolver access grants, enabling unauthorized access control bypass? (Critical)",
  "[File: scripts/utils.ts] [Function: findResolverAccessAddress()] [Cross-Program Collision] Can an attacker exploit the resolver access PDA seeds to collide with PDAs from other programs or other PDA derivations within the fusion protocol, potentially gaining unauthorized resolver privileges? (Critical)",
  "[File: scripts/utils.ts] [Function: findResolverAccessAddress()] [User Validation] Does the function validate that the user PublicKey is a valid Solana public key and not a system account or program ID, or can an attacker pass malicious addresses that derive to exploitable PDAs? (High)",
  "[File: scripts/utils.ts] [Function: findResolverAccessAddress()] [Seed String Format] Can an attacker exploit the UTF-8 encoding of 'resolver_access' to inject null bytes or special characters that alter PDA derivation, potentially bypassing resolver access controls? (Medium)",
  "[File: scripts/utils.ts] [Function: findWhitelistStateAddress()] [Single Seed Vulnerability] Does deriving the whitelist state PDA from only the 'whitelist_state' string (line 128) without additional entropy create a deterministic single PDA that could be pre-computed and exploited if the program ID is known? (Medium)",
  "[File: scripts/utils.ts] [Function: findWhitelistStateAddress()] [Program ID Validation] Does the function validate that programId is the correct whitelist program, or can an attacker pass a malicious program ID to derive a fake whitelist state PDA and bypass access controls? (High)",
  "[File: scripts/utils.ts] [Function: findWhitelistStateAddress()] [Cross-Program PDA Reuse] Can the whitelist state PDA collide with PDAs from other protocols using the same seed string, potentially allowing cross-protocol attacks or state confusion? (Medium)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Integer Overflow] Can the BN.toNumber() conversions on lines 150-152 overflow for large token amounts (srcAmount, minDstAmount, estimatedDstAmount), causing truncated values to be hashed and creating hash collisions for different orders? (Critical)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Precision Loss] Do the toNumber() conversions lose precision for amounts exceeding JavaScript's MAX_SAFE_INTEGER (2^53-1), allowing an attacker to create orders with amounts like 9007199254740992 and 9007199254740993 that hash to the same value? (Critical)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Hash Collision] Can an attacker craft two different OrderConfig objects that serialize to the same bytes due to the borsh serialization schema, producing identical order hashes and enabling escrow collision attacks? (Critical)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Pre-image Attack] Is the SHA256 hash function resistant to pre-image attacks where an attacker could find an OrderConfig that hashes to a specific target value, potentially allowing order impersonation? (High)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Second Pre-image Attack] Can an attacker find a second OrderConfig that hashes to the same value as a legitimate order, enabling them to hijack the escrow account and steal funds? (Critical)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Null Account Handling] Does the hashing logic properly handle null protocolDstAcc and integratorDstAcc (lines 176-177), or can an attacker exploit null vs undefined vs PublicKey.default differences to create hash collisions? (High)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Buffer Conversion] Can the toBuffer() calls on PublicKeys (lines 176-180) fail or produce unexpected results for invalid addresses, potentially causing hash calculation errors that lead to incorrect escrow derivation? (Medium)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Schema Mismatch] Does the orderConfigSchema (lines 186-229) exactly match the on-chain program's order serialization schema, or can schema mismatches cause different hashes to be computed client-side vs on-chain, leading to escrow access failures or manipulation? (Critical)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Array Serialization] Can the pointsAndTimeDeltas array serialization (lines 166-171, 208-217) be exploited by providing arrays that serialize inconsistently, potentially creating hash collisions for orders with different auction curves? (High)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Type Coercion] Do the type conversions in the values object (lines 148-181) properly handle edge cases like negative numbers, NaN, or Infinity, or can these cause unexpected serialization behavior leading to hash manipulation? (High)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Field Order] Does the borsh serialization maintain strict field ordering as defined in the schema, or can field reordering in the values object (lines 148-181) cause different hashes for logically identical orders? (High)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Optional Field Handling] Does the schema correctly handle optional fields (protocolDstAcc, integratorDstAcc) using the { option: ... } wrapper (lines 223-224), or can null vs Some(value) serialization differences be exploited for hash manipulation? (High)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [BN Serialization] Does the maxCancellationPremium BN value (line 160) serialize correctly through borsh without precision loss or overflow, or can large values cause hash calculation errors? (High)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Array Length Prefix] Does borsh automatically prepend array lengths for pointsAndTimeDeltas, or can an attacker exploit length prefix manipulation to create collisions between arrays of different sizes? (Medium)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Struct Nesting] Can the nested struct serialization (fee, dutchAuctionData) be exploited through padding or alignment issues that cause inconsistent byte layouts and hash collisions? (Medium)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Boolean Serialization] Do the boolean flags (srcAssetIsNative, dstAssetIsNative) serialize consistently as single bytes, or can true/false vs 1/0 differences be exploited for hash manipulation? (Low)",
  "[File: scripts/utils.ts] [Function: calculateOrderHash()] [Empty Array] Can an attacker provide an empty pointsAndTimeDeltas array that serializes differently than expected, potentially causing hash collisions with orders using default auction curves? (Medium)",
  "[File: scripts/utils.ts] [Constant: defaultFeeConfig] [Zero Fee Exploitation] Can an attacker exploit the zero-fee default configuration (lines 47-52) to create orders without paying protocol fees, potentially draining protocol revenue or enabling economic attacks? (Medium)",
  "[File: scripts/utils.ts] [Constant: defaultFeeConfig] [Fee Bypass] If orders use defaultFeeConfig, can they bypass fee validation checks in the on-chain program, allowing zero-fee orders where fees should be mandatory? (High)",
  "[File: scripts/utils.ts] [Constant: defaultAuctionData] [Far Future Start Time] Can the far-future startTime (0xffffffff - 32000, line 55) be exploited to create orders that never enter the auction phase, potentially locking funds indefinitely in escrow? (High)",
  "[File: scripts/utils.ts] [Constant: defaultAuctionData] [Timestamp Overflow] Can the startTime value (0xffffffff - 32000) cause integer overflow when compared against current timestamps in the on-chain program, potentially enabling orders to be filled before auction start? (High)",
  "[File: scripts/utils.ts] [Constant: defaultAuctionData] [Duration Exploitation] Can the 32000 second duration combined with far-future start time cause arithmetic overflow in auction end time calculations, potentially breaking auction mechanics? (High)",
  "[File: scripts/utils.ts] [Constant: defaultAuctionData] [Empty Curve] Can orders with empty pointsAndTimeDeltas array use a default rate formula that is exploitable for price manipulation or unfair auction execution? (Medium)",
  "[File: scripts/utils.ts] [Constant: defaultAuctionData] [Zero Initial Rate Bump] Does the zero initialRateBump (line 57) allow orders to start at minimum exchange rate, potentially enabling front-running or auction manipulation attacks? (Medium)",
  "[File: scripts/utils.ts] [Function: defaultExpirationTime()] [Timestamp Precision] Does the bitwise NOT operator (~~) on line 136 correctly truncate to integer seconds, or can floating-point precision errors cause incorrect expiration times that enable premature or delayed order expiration exploits? (Medium)",
  "[File: scripts/utils.ts] [Function: defaultExpirationTime()] [Clock Skew] Can an attacker exploit differences between client timestamp (Date.getTime()) and on-chain clock to create orders with expiration times that differ from expected, enabling timing attacks? (Medium)",
  "[File: scripts/utils.ts] [Function: defaultExpirationTime()] [Timezone Manipulation] Does the function account for timezone differences, or can an attacker exploit UTC vs local time confusion to manipulate order expiration timing? (Low)",
  "[File: scripts/utils.ts] [Function: defaultExpirationTime()] [86400 Second Constant] Can the hardcoded 1-day expiration (86400 seconds) be exploited in combination with auction timing to create orders that expire mid-auction, potentially causing failed fills or locked funds? (Medium)",
  "[File: scripts/utils.ts] [Function: defaultExpirationTime()] [Overflow] Can the addition (~~(new Date().getTime() / 1000) + 86400) overflow u32 for timestamps far in the future, causing expiration wraparound and allowing orders to be valid indefinitely? (High)",
  "[File: scripts/utils.ts] [Function: defaultExpirationTime()] [Past Expiration] Does the function prevent accidentally creating orders with past expiration times if system clock is incorrect, or can this cause immediate order expiration and DoS? (Low)",
  "[File: scripts/utils.ts] [Function: getClusterUrlEnv()] [Injection Attack] Can an attacker manipulate the CLUSTER_URL environment variable to point to a malicious RPC endpoint, enabling man-in-the-middle attacks or fake transaction confirmations? (High)",
  "[File: scripts/utils.ts] [Function: getClusterUrlEnv()] [Missing Validation] Does the function validate that the cluster URL is a valid and trusted endpoint, or can arbitrary URLs be used to redirect transactions to attacker-controlled nodes? (High)",
  "[File: scripts/utils.ts] [Function: getClusterUrlEnv()] [Empty String] Can an empty but defined CLUSTER_URL environment variable bypass the null check (line 141) and cause connection failures or unexpected behavior? (Low)",
  "[File: scripts/utils.ts] [Function: loadKeypairFromFile()] [Path Traversal] Can an attacker exploit the path resolution logic (lines 73-75) to read keypair files from arbitrary filesystem locations using ../ sequences, potentially stealing private keys? (Critical)",
  "[File: scripts/utils.ts] [Function: loadKeypairFromFile()] [Symlink Attack] Can an attacker use symbolic links to make filePath point to a different file than intended, allowing unauthorized keypair access or replacement? (High)",
  "[File: scripts/utils.ts] [Function: loadKeypairFromFile()] [Homedir Expansion] Can the tilde expansion (lines 73-75) be exploited to access other users' home directories on multi-user systems, potentially stealing keypairs? (Medium)",
  "[File: scripts/utils.ts] [Function: loadKeypairFromFile()] [Race Condition] Can an attacker replace the keypair file between the readFileSync call (line 78) and its use, enabling private key substitution attacks? (Medium)",
  "[File: scripts/utils.ts] [Function: loadKeypairFromFile()] [JSON Injection] Can maliciously crafted JSON in the keypair file exploit the JSON.parse call (line 79) to cause prototype pollution or code execution? (High)",
  "[File: scripts/utils.ts] [Function: loadKeypairFromFile()] [Array Length] Does the function validate the length of the secret key array after JSON parsing, or can truncated or oversized arrays cause keypair generation failures or security issues? (Medium)",
  "[File: scripts/utils.ts] [Function: loadKeypairFromFile()] [Error Information Leak] Does the error message on lines 84-86 leak sensitive information about file paths or system structure that could aid reconnaissance for further attacks? (Low)",
  "[File: scripts/utils.ts] [Function: loadKeypairFromFile()] [Buffer Overflow] Can the Uint8Array.from conversion (line 81) overflow if the JSON array contains values outside 0-255 range, potentially causing memory corruption? (Medium)",
  "[File: scripts/utils.ts] [Function: loadKeypairFromFile()] [Invalid Secret Key] Does Keypair.fromSecretKey validate that the secret key is cryptographically valid, or can malformed keys cause unexpected behavior or security vulnerabilities? (Medium)",
  "[File: scripts/utils.ts] [Function: getTokenDecimals()] [RPC Manipulation] Can an attacker exploit a compromised or malicious RPC endpoint to return fake decimal values, causing incorrect amount calculations and potential fund loss? (High)",
  "[File: scripts/utils.ts] [Function: getTokenDecimals()] [Mint Validation] Does the function verify that the mint address corresponds to a valid SPL token program mint, or can an attacker pass arbitrary account addresses that return unexpected decimal values? (High)",
  "[File: scripts/utils.ts] [Function: getTokenDecimals()] [Race Condition] Can the mint decimals be modified on-chain between fetching and using them, causing calculation inconsistencies in order creation or filling? (Low)",
  "[File: scripts/utils.ts] [Function: getTokenDecimals()] [Cache Poisoning] If decimal values are cached, can an attacker poison the cache with incorrect values, affecting multiple orders? (Medium)",
  "[File: scripts/utils.ts] [Function: getTokenDecimals()] [Decimal Range] Does the function validate that decimals are within the valid SPL token range (0-255), or can out-of-range values cause arithmetic errors in amount calculations? (Low)",
  "[File: scripts/utils.ts] [Type: OrderConfig] [Field Addition] Can an attacker add extra fields to OrderConfig beyond those in the type definition, and do these extra fields affect the order hash calculation or on-chain validation? (High)",
  "[File: scripts/utils.ts] [Type: FeeConfig] [Null vs Undefined] Does the type system distinguish between null and undefined for protocolDstAcc/integratorDstAcc, and can this distinction be exploited to bypass fee distribution or create hash collisions? (High)",
  "[File: scripts/utils.ts] [Type: ReducedOrderConfig] [IDL Mismatch] If the IDL changes but the type extraction (lines 12-16) isn't updated, can this cause type mismatches that lead to incorrect order hash calculation or serialization errors? (High)",
  "[File: scripts/utils.ts] [Type: ReducedFeeConfig] [Type Inference] Can the type inference from IDL (lines 18-21) produce different types than expected, causing serialization mismatches between client and on-chain program? (Medium)",
  "[File: scripts/utils.ts] [Type: Escrow] [Type Extraction] If the Escrow type extracted from IDL (lines 39-40) doesn't match the actual on-chain account structure, can this cause deserialization errors that enable account manipulation? (High)",
  "[File: scripts/utils.ts] [Type: AuctionData] [Type Safety] Does the AuctionData type (lines 42-45) enforce constraints on startTime, duration, and pointsAndTimeDeltas, or can type-unsafe values cause auction manipulation? (Medium)",
  "[File: scripts/utils.ts] [Schema: orderConfigSchema] [u64 Overflow] Can the u64 type definitions for srcAmount, minDstAmount, estimatedDstAmount (lines 189-191) overflow when converting from BN, causing incorrect serialization? (High)",
  "[File: scripts/utils.ts] [Schema: orderConfigSchema] [u32 Range] Can u32 fields (id, expirationTime, startTime, duration, cancellationAuctionDuration) overflow if provided with values > 2^32-1, causing wraparound in hash calculation? (High)",
  "[File: scripts/utils.ts] [Schema: orderConfigSchema] [u16 Limits] Can u16 fields (protocolFee, integratorFee, initialRateBump, rateBump, timeDelta) be exploited with max values (65535) to cause fee calculation overflows or auction manipulation? (High)",
  "[File: scripts/utils.ts] [Schema: orderConfigSchema] [u8 Range] Can the u8 surplusPercentage field (line 199) be set to values that cause percentage calculations to overflow or produce incorrect fee distributions? (Medium)",
  "[File: scripts/utils.ts] [Schema: orderConfigSchema] [Array Type Safety] Does the array type definition for pointsAndTimeDeltas (lines 208-217) enforce maximum array length, or can unbounded arrays cause excessive gas costs or memory issues? (Medium)",
  "[File: scripts/utils.ts] [Schema: orderConfigSchema] [Fixed-Length Arrays] Do the fixed-length u8 arrays for public keys (len: 32, lines 223-227) properly validate input length, or can shorter/longer inputs cause serialization errors? (High)",
  "[File: scripts/utils.ts] [Schema: orderConfigSchema] [Nested Struct Alignment] Can the nested struct definitions (fee, dutchAuctionData) cause byte alignment issues that lead to different serialization between client and on-chain program? (Medium)",
  "[File: scripts/utils.ts] [Integration: calculateOrderHash + findEscrowAddress] Can an attacker exploit inconsistencies between the order hash calculation and escrow PDA derivation to create orders where the hash doesn't match the escrow account, enabling fund theft? (Critical)",
  "[File: scripts/utils.ts] [Integration: getTokenDecimals + calculateOrderHash] Can incorrect token decimals cause amount fields in the order hash to be calculated incorrectly, leading to orders that can't be filled or have wrong exchange rates? (High)",
  "[File: scripts/utils.ts] [Integration: defaultExpirationTime + calculateOrderHash] Can timestamp discrepancies between client and on-chain clocks cause orders to have expiration times in the hash that don't match on-chain validation, enabling expiration bypass? (High)",
  "[File: scripts/utils.ts] [Integration: defaultAuctionData + calculateOrderHash] Can the default auction parameters in combination with hash calculation create orders with auction configurations that are exploitable for price manipulation? (High)",
  "[File: scripts/utils.ts] [Integration: loadKeypairFromFile + findResolverAccessAddress] Can a compromised keypair file be used to derive resolver access PDAs that grant unauthorized filling privileges? (Critical)",
  "[File: scripts/utils.ts] [Borsh: borsh.serialize] Can the borsh.serialize call (line 183) throw exceptions for malformed data that aren't caught, causing DoS when creating orders? (Medium)",
  "[File: scripts/utils.ts] [Borsh: Version Compatibility] Does the borsh library version match the on-chain program's borsh version, or can version mismatches cause serialization differences and hash collisions? (High)",
  "[File: scripts/utils.ts] [Borsh: Enum Handling] If the schema includes enums (not visible in current types), can enum discriminant differences cause serialization mismatches? (Medium)",
  "[File: scripts/utils.ts] [Borsh: String Encoding] Are all string fields (like 'escrow', 'resolver_access') consistently UTF-8 encoded, or can encoding differences cause PDA derivation mismatches? (Medium)",
  "[File: scripts/utils.ts] [Borsh: Padding] Does borsh add padding bytes for struct alignment, and can an attacker exploit padding differences to create hash collisions? (Medium)",
  "[File: scripts/utils.ts] [Borsh: Option<T>] Does the option type wrapper correctly encode null as None and non-null as Some(value), or can encoding differences be exploited for hash manipulation? (High)",
  "[File: scripts/utils.ts] [Borsh: Vec<T>] Does the array serialization prepend the correct length prefix in little-endian u32 format, and can length prefix manipulation cause deserialization attacks? (Medium)",
  "[File: scripts/utils.ts] [Borsh: Recursive Types] If the schema contains recursive or circular type references, can this cause infinite serialization loops or stack overflow? (Low)",
  "[File: scripts/utils.ts] [Crypto: sha256] Does the SHA256 implementation from @noble/hashes (line 7, 183) match the on-chain SHA256, or can implementation differences cause hash mismatches? (Critical)",
  "[File: scripts/utils.ts] [Crypto: Hash Length] Does the SHA256 output always produce 32 bytes, and is this validated before using it in PDA derivation to prevent truncated hash exploits? (High)",
  "[File: scripts/utils.ts] [Crypto: Precomputed Hashes] Can an attacker precompute order hashes for specific target PDAs to create escrow collisions by finding orders that hash to controlled values? (High)",
  "[File: scripts/utils.ts] [Crypto: Hash Malleability] Can the order configuration be modified in ways that don't change semantic meaning but produce different hashes, enabling replay or substitution attacks? (Medium)",
  "[File: scripts/utils.ts] [Crypto: Weak Randomness] Do any parts of the order configuration use weak randomness sources that could make hash values predictable or allow collision attacks? (Medium)",
  "[File: scripts/utils.ts] [Crypto: Side Channel] Can timing differences in the SHA256 computation leak information about order configurations that enables targeted collision attacks? (Low)",
  "[File: scripts/utils.ts] [Memory: Large Arrays] Can an attacker create orders with extremely large pointsAndTimeDeltas arrays that cause memory exhaustion during serialization and hash calculation? (Medium)",
  "[File: scripts/utils.ts] [Memory: Buffer Allocation] Does the Buffer.from conversion (line 99) for orderHash validate buffer size, or can enormous strings cause out-of-memory errors? (Low)",
  "[File: scripts/utils.ts] [Memory: String Manipulation] Can the regex matching and array operations (lines 96-99) be exploited with very long hex strings to cause performance degradation or DoS? (Low)",
  "[File: scripts/utils.ts] [Memory: File Size] Does loadKeypairFromFile limit the file size being read, or can an attacker cause DoS by pointing to extremely large files? (Low)",
  "[File: scripts/utils.ts] [Replay: Order Hash] Can an attacker replay an order hash from a previous order after it's been filled or cancelled to re-access the same escrow PDA and steal residual funds? (Critical)",
  "[File: scripts/utils.ts] [Replay: PDA Reuse] After an escrow account is closed, can the same PDA be derived again for a new order, potentially accessing leftover lamports or account data? (High)",
  "[File: scripts/utils.ts] [Race: Parallel Hash Calculation] If multiple clients calculate the same order hash simultaneously, can race conditions in escrow creation cause only one to succeed while others fail with DoS? (Low)",
  "[File: scripts/utils.ts] [Race: Configuration Changes] Can order configuration be modified between hash calculation and on-chain submission, causing the submitted order to have a different hash than expected? (Medium)",
  "[File: scripts/utils.ts] [Validation: PublicKey Format] Do functions accepting PublicKey parameters validate they are well-formed base58 addresses, or can malformed addresses cause unexpected PDA derivation? (Medium)",
  "[File: scripts/utils.ts] [Validation: Negative Values] Can negative values be passed for amounts, fees, or time parameters, and do they get serialized as large unsigned integers due to two's complement representation? (High)",
  "[File: scripts/utils.ts] [Validation: Zero Values] Can zero values for critical fields (srcAmount, minDstAmount) pass through calculateOrderHash and create invalid orders that can't be filled? (Medium)",
  "[File: scripts/utils.ts] [Validation: Max Values] Can maximum u64/u32/u16 values cause overflow in subsequent on-chain calculations even if they serialize correctly in the hash? (High)",
  "[File: scripts/utils.ts] [Validation: Field Consistency] Can inconsistent fields (e.g., minDstAmount > estimatedDstAmount) pass through hash calculation and create economically irrational orders exploitable by resolvers? (Medium)",
  "[File: scripts/utils.ts] [Validation: Time Ordering] Can auction startTime be after expirationTime, and does this create orders that can never be validly filled? (Medium)",
  "[File: scripts/utils.ts] [Validation: Fee Percentage] Can fee percentages (protocolFee, integratorFee, surplusPercentage) sum to >100%, causing incorrect fee distribution that drains orders? (High)",
  "[File: scripts/utils.ts] [Validation: Duration Bounds] Can auction duration be zero or extremely large, and does this break auction pricing calculations on-chain? (High)",
  "[File: scripts/utils.ts] [Validation: Rate Bump Overflow] Can initialRateBump and rateBump values in pointsAndTimeDeltas cause rate calculations to overflow during auction execution? (High)",
  "[File: scripts/utils.ts] [Validation: Time Delta Sequence] Can pointsAndTimeDeltas have non-monotonic or negative timeDelta values that break auction curve calculations? (High)",
  "[File: scripts/utils.ts] [Dependency: @solana/web3.js] Can vulnerabilities in the Solana web3.js library affect PDA derivation or PublicKey operations, enabling attacks on escrow addresses? (High)",
  "[File: scripts/utils.ts] [Dependency: @coral-xyz/anchor] Can the Anchor framework's utility functions (anchor.utils.bytes.utf8.encode) have bugs that affect seed generation for PDAs? (Medium)",
  "[File: scripts/utils.ts] [Dependency: @solana/spl-token] Can vulnerabilities in the SPL token library affect mint account fetching or decimal parsing, causing incorrect amount calculations? (Medium)",
  "[File: scripts/utils.ts] [Dependency: @noble/hashes] Can the @noble/hashes library produce incorrect SHA256 hashes due to bugs, causing order hash mismatches with on-chain calculations? (Critical)",
  "[File: scripts/utils.ts] [Dependency: borsh] Can the borsh serialization library have bugs that cause inconsistent serialization between client and on-chain program? (Critical)",
  "[File: scripts/utils.ts] [Dependency: fs/path/os] Can vulnerabilities in Node.js built-in modules affect keypair file loading or path resolution, enabling path traversal attacks? (Medium)",
  "[File: scripts/utils.ts] [Error: Silent Failures] Can errors in PDA derivation, hash calculation, or serialization fail silently without throwing, causing incorrect values to be used in transactions? (High)",
  "[File: scripts/utils.ts] [Error: Exception Handling] If borsh.serialize throws an exception for invalid data, is it caught and handled, or does it crash the order creation process? (Medium)",
  "[File: scripts/utils.ts] [Error: Partial Success] Can some fields in OrderConfig be serialized successfully while others fail, creating partially hashed data that leads to incorrect order hashes? (High)",
  "[File: scripts/utils.ts] [Error: RPC Failures] If getTokenDecimals fails due to RPC errors, is the error propagated correctly, or does it return undefined causing subsequent NaN calculations? (Medium)",
  "[File: scripts/utils.ts] [Error: Network Timeout] Can network timeouts during mint account fetching cause stale or default decimal values to be used in order creation? (Low)",
  "[File: scripts/utils.ts] [Logic: Fee Configuration Bypass] Can an attacker set all fee-related PublicKeys to null but set non-zero fee percentages, bypassing fee payment while the order claims to have fees configured? (High)",
  "[File: scripts/utils.ts] [Logic: Auction Curve Manipulation] Can an attacker construct pointsAndTimeDeltas arrays that create auction curves with sudden price drops, enabling MEV or front-running attacks? (High)",
  "[File: scripts/utils.ts] [Logic: Mint Confusion] Can an attacker create orders with srcMint == dstMint, and does the hash calculation allow such orders that would be economically meaningless? (Medium)",
  "[File: scripts/utils.ts] [Logic: Self-Receiver] Can an attacker set the receiver to be the same as the maker, and does this enable any exploits in fund flow or fee distribution? (Low)",
  "[File: scripts/utils.ts] [Logic: Native Asset Flags] Can srcAssetIsNative or dstAssetIsNative flags be set inconsistently with the mint addresses (e.g., native flag true but mint is not SOL wrapper), causing wrapping/unwrapping exploits? (High)",
  "[File: scripts/utils.ts] [Logic: Cancellation Premium] Can maxCancellationPremium be set to exceed srcAmount, allowing resolvers who cancel orders to extract more than the escrowed amount? (Critical)",
  "[File: scripts/utils.ts] [Logic: Estimated vs Min] Can estimatedDstAmount be set much lower than minDstAmount, creating orders that signal one price but enforce another, enabling bait-and-switch attacks? (Medium)",
  "[File: scripts/utils.ts] [Logic: Zero Duration Auction] Can setting auction duration to 0 cause the auction to complete instantly, bypassing price discovery and enabling instant arbitrage? (High)",
  "[File: scripts/utils.ts] [Logic: ID Collision] Can two orders from the same maker use the same ID field, and does this cause escrow PDA collision if other fields differ but ID remains same? (Critical)",
  "[File: scripts/utils.ts] [Protocol: Cross-Order Interference] Can manipulating order hashes enable an attacker to interfere with other users' orders by creating hash collisions that derive to same PDAs? (Critical)",
  "[File: scripts/utils.ts] [Protocol: Resolver Griefing] Can a malicious resolver use knowledge of the PDA derivation logic to pre-create accounts at escrow addresses, preventing legitimate order creation? (High)",
  "[File: scripts/utils.ts] [Protocol: Whitelist Bypass] Can manipulating the resolver access PDA derivation allow a non-whitelisted user to derive the same PDA as a whitelisted resolver and fill orders? (Critical)",
  "[File: scripts/utils.ts] [Protocol: Fee Recipient Manipulation] Can an attacker set protocolDstAcc or integratorDstAcc to addresses they control, siphoning fees meant for the protocol or integrators? (High)",
  "[File: scripts/utils.ts] [Protocol: Escrow Draining] Can understanding the escrow PDA derivation allow an attacker to find and drain escrow accounts from cancelled or expired orders? (Critical)",
  "[File: scripts/utils.ts] [Protocol: Order Book Manipulation] Can creating many orders with carefully chosen hashes enable an attacker to manipulate the order book or auction prices system-wide? (Medium)",
  "[File: scripts/utils.ts] [Auction: Start Time Manipulation] Can setting startTime to far future (as in defaultAuctionData) combined with short expiration time create orders that expire before auction starts, locking funds permanently? (High)",
  "[File: scripts/utils.ts] [Auction: Rate Bump Ordering] Can pointsAndTimeDeltas be ordered such that rate bumps decrease over time instead of increase, inverting the auction and enabling price manipulation? (High)",
  "[File: scripts/utils.ts] [Auction: Time Delta Overflow] Can cumulative time deltas in pointsAndTimeDeltas exceed the auction duration, causing undefined behavior in rate calculation? (High)",
  "[File: scripts/utils.ts] [Auction: Discontinuous Curves] Can gaps or overlaps in pointsAndTimeDeltas time ranges create discontinuous auction curves that enable front-running specific price points? (Medium)",
  "[File: scripts/utils.ts] [Auction: Empty Curve with Start Time] Can combining empty pointsAndTimeDeltas with future startTime cause orders to use default formula starting far in future, making them unfillable? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [PDA Collision] Can an attacker craft a malicious order_hash argument that collides with the escrow PDA seeds (escrow + maker + order_hash) to cancel another user's order, leading to unauthorized token extraction from victim's escrow? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Access Control Bypass] Does the cancel instruction validate that the maker signer actually owns the escrow PDA, or can an attacker pass a valid maker signature with a manipulated order_hash to drain arbitrary escrows? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Token Theft] Can an attacker exploit the optional maker_src_ata account to redirect refunded tokens to a different account by manipulating the PDA derivation seeds, bypassing the intended maker's ATA? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Native SOL Handling] If order_src_asset_is_native is true, can an attacker exploit the SOL unwrapping logic by providing a false value to extract WSOL tokens instead of native SOL, causing fund loss or accounting errors? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Native SOL Handling] Can an attacker set order_src_asset_is_native to false when it should be true, preventing proper SOL unwrapping and locking funds permanently in WSOL form in the escrow? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [PDA Validation] Does the escrow PDA derivation (seeds: 'escrow', maker, order_hash) properly validate the order_hash length (32 bytes), or can an attacker pass truncated/padded hashes to create PDA collisions? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Account Substitution] Can an attacker substitute the src_mint account with a different token mint that has the same address as the original, causing the escrow_src_ata PDA to resolve to a different account and drain wrong tokens? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Token Program Manipulation] Can an attacker provide a malicious src_token_program account instead of the legitimate SPL Token program to bypass transfer checks and extract tokens without proper validation? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [ATA PDA Collision] Can an attacker exploit the escrow_src_ata PDA derivation (seeds: escrow, src_token_program, src_mint) by manipulating the token program address to access a different ATA containing more valuable tokens? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Optional Account Exploit] Since maker_src_ata is optional, can an attacker call cancel without providing this account when order_src_asset_is_native is false, causing tokens to be locked or sent to an unintended destination? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Reentrancy] Can an attacker create a malicious token program that calls back into the cancel instruction during the token transfer, allowing double-spending or state corruption before escrow closure? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [State Corruption] If cancel is called on a partially filled order, does the instruction properly handle the remaining balance, or can an attacker drain more tokens than their escrow balance by exploiting missing balance checks? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Signature Verification] Can an attacker bypass the maker signer requirement by exploiting the account constraint validation, potentially cancelling orders without proper authorization? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Escrow Closure Bypass] Can an attacker prevent escrow account closure by manipulating the account state, leaving orphaned escrow accounts that lock funds indefinitely? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [ATA Creation Exploit] If maker_src_ata doesn't exist and is optional, can an attacker exploit the missing account to cause the instruction to fail repeatedly, creating a permanent DoS on order cancellation? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Access Control Bypass] Can an attacker create a fake resolver_access PDA with seeds ('resolver_access', attacker_address) that passes validation without proper whitelist program verification, allowing unauthorized order cancellation? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [PDA Collision] Can an attacker manipulate the resolver_access PDA seeds to collide with a legitimate resolver's access account, impersonating a whitelisted resolver to cancel orders and collect premiums? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Cross-Program Invocation] Does the resolver_access PDA properly validate that it belongs to the whitelist program (address: 46r3AXfEv6QxHhfFw848oK87bV6axq6YnVJrmvhkXe5d), or can an attacker provide a fake PDA from a malicious program? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Fee Manipulation] Can a malicious resolver exploit the reward_limit parameter in cancel_by_resolver to extract more cancellation premium than max_cancellation_premium specified in the OrderConfig's FeeConfig, draining maker funds? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Fee Calculation Overflow] Can an attacker craft an OrderConfig with extreme max_cancellation_premium values that cause integer overflow when calculating the actual premium to pay the resolver, leading to incorrect fee distribution? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Expiration Bypass] Can a resolver cancel an order before expiration by exploiting missing expiration validation, collecting premiums on orders that should still be fillable by other resolvers? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Premium Theft] Can an attacker provide a manipulated reward_limit that's higher than the actual cancellation premium calculation, extracting more SOL from the maker account than intended? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Account Substitution] Can an attacker substitute the maker account with a different address to redirect cancellation premium payments to themselves instead of the legitimate resolver? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Maker Receiver Manipulation] Can an attacker manipulate the maker_receiver account to redirect refunded tokens to a different address than the maker's intended receiver, stealing order funds? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Optional Fee Account Exploit] Can an attacker exploit the optional protocol_dst_acc and integrator_dst_acc accounts by omitting them when they should be present (based on FeeConfig), avoiding fee payments and stealing protocol revenue? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Fee Config Inconsistency] Can an attacker craft an OrderConfig with protocol_fee > 0 but omit protocol_dst_acc, bypassing the InconsistentProtocolFeeConfig error check to avoid paying protocol fees? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Integrator Fee Bypass] Can an attacker craft an OrderConfig with integrator_fee > 0 but omit integrator_dst_acc, bypassing the InconsistentIntegratorFeeConfig error check to steal integrator fees? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Native Asset Confusion] Can an attacker provide inconsistent src_mint and dst_mint with the order's src_asset_is_native and dst_asset_is_native flags in OrderConfig to exploit SOL wrapping/unwrapping logic? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Escrow Balance Exploit] Can an attacker cancel an order with escrow_src_ata containing more tokens than the original src_amount, extracting the excess tokens during cancellation without proper accounting? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Resolver Signature Bypass] Can an attacker bypass the resolver signer requirement by exploiting account delegation or proxy patterns to cancel orders without proper resolver authorization? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [OrderConfig Manipulation] Can an attacker provide a modified OrderConfig struct with altered fee parameters that differ from the original order, causing incorrect fee calculations during cancellation? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Time Manipulation] Can an attacker exploit the cancellation_auction_duration field in OrderConfig by setting it to extreme values (0 or u32::MAX) to manipulate premium calculations? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [ATA Validation Bypass] Since maker_src_ata is optional, can an attacker cancel native SOL orders without providing the maker's SOL ATA, causing funds to be lost or sent to system program? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Forbidden Cancellation Bypass] Can an attacker bypass the CancelOrderByResolverIsForbidden error check by manipulating the order expiration time or cancellation_auction_duration to cancel orders that should be maker-only cancellable? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [System Program Exploit] Can an attacker replace the system_program account with a malicious program to intercept SOL transfers during premium payments and redirect funds? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Token Theft] Can an attacker create an order with src_amount set to 0 or u64::MAX, bypassing amount validation to create malicious orders that break protocol invariants or enable token theft during fills? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [PDA Collision] Can an attacker craft multiple orders with different parameters but the same PDA derivation (escrow seeds: 'escrow', maker, order_hash), causing escrow account collisions that overwrite existing orders and steal locked tokens? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Escrow Authority Exploit] Can an attacker manipulate the escrow PDA to become the authority for an ATA containing tokens from a different user's order, enabling cross-order token theft? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [ATA Creation Exploit] Can an attacker exploit the associated_token_program to create the escrow_src_ata for a different escrow PDA, redirecting token locks to unauthorized accounts? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Amount Validation Bypass] Can an attacker create an order with min_dst_amount > estimated_dst_amount, causing the InvalidEstimatedTakingAmount error to be bypassable and enabling unfillable orders that lock tokens indefinitely? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Fee Overflow] Can an attacker craft a FeeConfig with protocol_fee + integrator_fee > 100000 basis points (100%), causing fee calculations to overflow and extract more than 100% of order value? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Surplus Fee Exploit] Can an attacker set FeeConfig.surplus_percentage > 100 (basis points where BASE_1E2 = 100%), causing the protocol to take more than 100% of surplus during fills, draining resolver profits? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Max Cancellation Premium Manipulation] Can an attacker set FeeConfig.max_cancellation_premium to u64::MAX, forcing resolvers to pay exorbitant premiums for cancellation and creating permanent order locks? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Expiration Time Manipulation] Can an attacker set OrderConfig.expiration_time to 0 or in the past, creating immediately expired orders that lock tokens in escrow without any fill window? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Expiration Overflow] Can an attacker set OrderConfig.expiration_time to u32::MAX, creating orders that never expire and lock tokens indefinitely if maker loses access to their account? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Native Asset Flag Mismatch] Can an attacker create an order with src_asset_is_native set to true but provide a non-WSOL mint as src_mint, causing inconsistent native asset handling during cancellation or fills? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Destination Asset Confusion] Can an attacker set dst_asset_is_native to true but provide protocol_dst_acc and integrator_dst_acc accounts that don't match SOL's WSOL mint, bypassing fee validations? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Token Program Substitution] Can an attacker provide a malicious src_token_program that mimics SPL Token but has backdoors, allowing unauthorized token extraction from escrow after order creation? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Maker Receiver Manipulation] Can an attacker set maker_receiver to an arbitrary address they control instead of their own wallet, redirecting all filled order proceeds to the attacker's account? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Optional ATA Exploit] Since maker_src_ata is optional, can an attacker create native SOL orders without providing their SOL ATA, causing SOL wrapping to fail and locking native SOL in an inaccessible state? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Protocol Fee Account Validation] Can an attacker provide a protocol_dst_acc that isn't the legitimate protocol treasury, redirecting protocol fees to their own account during order fills? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Integrator Fee Theft] Can an attacker provide an integrator_dst_acc they control instead of the legitimate integrator, stealing integrator fees from all fills of their order? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Fee Account Consistency] Can an attacker create an order with protocol_fee = 0 but still provide protocol_dst_acc, potentially exploiting the InconsistentProtocolFeeConfig validation to create malformed orders? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Integrator Fee Consistency] Can an attacker create an order with integrator_fee = 0 but still provide integrator_dst_acc, potentially exploiting the InconsistentIntegratorFeeConfig validation to create malformed orders? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [AuctionData Manipulation] Can an attacker craft AuctionData with start_time in the past or future, causing auction rate calculations to overflow or underflow during fills? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Auction Duration Exploit] Can an attacker set AuctionData.duration to 0 or u32::MAX, causing division by zero or timestamp overflow in rate bump calculations during order fills? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Initial Rate Bump Overflow] Can an attacker set AuctionData.initial_rate_bump to u16::MAX, causing rate calculations to overflow when multiplied with amounts during fill operations? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Points Vector Exploit] Can an attacker provide an empty or excessively large points_and_time_deltas vector in AuctionData, causing DoS through compute unit exhaustion or bypassing auction mechanics? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Rate Bump Monotonicity] Can an attacker craft points_and_time_deltas with non-monotonic rate_bump values, causing rate calculations to decrease over time instead of increase, enabling auction manipulation? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Time Delta Overflow] Can an attacker set PointAndTimeDelta.time_delta values that sum to exceed u32::MAX or auction duration, causing timestamp calculations to overflow during fills? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Cancellation Auction Duration] Can an attacker set cancellation_auction_duration > expiration_time, causing resolver cancellations to be enabled for longer than the order's lifetime and breaking the intended cancellation mechanics? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Order ID Collision] Can an attacker create multiple orders with the same OrderConfig.id from the same maker address, causing order hash collisions that overwrite existing escrows? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Token Lock Without Transfer] Can an attacker exploit the token transfer from maker_src_ata to escrow_src_ata to create an order without actually locking tokens, leaving escrow underfunded for subsequent fills? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [System Program Exploit] Can an attacker replace the system_program account with a malicious program to intercept escrow account creation and manipulate its initialization? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Associated Token Program Exploit] Can an attacker replace the associated_token_program with a malicious program to create fake ATAs that appear valid but have backdoor access? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Access Control Bypass] Can an attacker call fill without a valid resolver_access PDA by creating a fake PDA that isn't validated against the whitelist program, allowing unauthorized order filling? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Resolver Access PDA Forgery] Can an attacker forge a resolver_access PDA with seeds ('resolver_access', attacker_address) from a malicious program that isn't the whitelist program (address: 46r3A...), bypassing access control? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Amount Manipulation] Can an attacker provide an amount parameter that's greater than the remaining order balance in escrow_src_ata, extracting more tokens than available through insufficient balance checks? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Amount Underflow] Can an attacker provide amount = 0 to fill an order, bypassing amount validation and causing accounting errors or enabling repeated fills that drain escrow? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Partial Fill Exploit] Can an attacker partially fill an order with a manipulated amount that causes the remaining escrow balance to be insufficient for future fills, creating permanent order locks? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Rate Calculation Overflow] Can an attacker fill an order at a time when the auction rate bump calculation overflows (start_time + duration + time deltas), causing incorrect dst_amount calculations that result in token theft? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Expiration Bypass] Can an attacker fill an expired order by exploiting missing expiration validation, or by manipulating the clock sysvar to make an expired order appear valid? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Maker Receiver Substitution] Can an attacker substitute the maker_receiver account with their own address to redirect dst tokens that should go to the maker, stealing order proceeds? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Taker Source ATA Exploit] Can an attacker provide a taker_src_ata that belongs to a different owner, causing src tokens from escrow to be sent to a victim's account without consuming the attacker's tokens? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Token Program Mismatch] Can an attacker provide different src_token_program and dst_token_program accounts that aren't the legitimate SPL Token programs, bypassing transfer validations? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [ATA Creation Exploit] Can an attacker exploit the optional maker_dst_ata or taker_dst_ata accounts by causing the associated_token_program to create ATAs with incorrect ownership or mint? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Missing Maker DST ATA] If maker_dst_ata is optional and not provided, can an attacker cause the MissingMakerDstAta error to be bypassed when dst_asset_is_native is false, losing maker's dst tokens? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Missing Taker DST ATA] If taker_dst_ata is optional and not provided, can an attacker cause the MissingTakerDstAta error to be bypassed, receiving surplus or fee distributions they shouldn't receive? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Protocol Fee Manipulation] Can an attacker manipulate the OrderConfig.fee.protocol_fee calculation by providing extreme amount values that cause the fee to underflow or overflow? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Integrator Fee Manipulation] Can an attacker manipulate the OrderConfig.fee.integrator_fee calculation to pay less than required or overflow the fee calculation to extract protocol value? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Surplus Fee Bypass] Can an attacker manipulate the OrderConfig.fee.surplus_percentage calculation by providing an amount that results in negative or zero surplus, bypassing surplus fee payments? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Protocol Destination Account Exploit] Can an attacker exploit the optional protocol_dst_acc by omitting it when protocol_fee > 0, avoiding protocol fee payments and stealing protocol revenue? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Integrator Destination Account Exploit] Can an attacker exploit the optional integrator_dst_acc by omitting it when integrator_fee > 0, avoiding integrator fee payments? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Fee Distribution Precision Loss] Can an attacker exploit rounding errors in fee calculations (protocol_fee + integrator_fee + surplus_fee) to retain dust amounts that accumulate to significant value over many fills? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Native SOL Wrapping Exploit] If src_asset_is_native is true, can an attacker exploit the SOL unwrapping process to extract more native SOL than they deposited in WSOL? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Native DST SOL Unwrapping] If dst_asset_is_native is true, can an attacker manipulate the SOL unwrapping to the maker to cause the wrapped SOL to remain locked without proper conversion to native SOL? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Escrow Closure Exploit] After a full fill, can an attacker prevent escrow account closure to cause rent exemption refunds to be lost or misdirected? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Escrow Balance Inconsistency] Can an attacker fill an order when escrow_src_ata has more tokens than the order's src_amount, extracting the excess tokens without proper accounting? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Auction Start Time Manipulation] Can an attacker fill an order before the auction's start_time by exploiting missing validation, getting better rates than intended? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Rate Bump Calculation Exploit] Can an attacker exploit the piecewise linear rate bump calculation (initial_rate_bump + points_and_time_deltas) to fill orders at manipulated rates that don't match the intended auction curve? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Time Delta Overflow in Fill] Can an attacker fill an order at a time when the cumulative time_delta calculations overflow, causing the rate bump to wrap around and provide advantageous rates? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Min Dst Amount Bypass] Can an attacker fill an order with a calculated dst_amount less than OrderConfig.min_dst_amount by exploiting insufficient validation, causing maker to receive less than minimum? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Estimated Dst Amount Exploitation] Can an attacker craft fills that exploit the relationship between estimated_dst_amount and actual calculated dst_amount to manipulate surplus calculations? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Maker Account Drain] Can an attacker substitute the maker account to cause SOL rent payments or fee distributions to drain a victim's wallet instead of the legitimate maker? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Taker Signature Bypass] Can an attacker bypass the taker signer requirement through account delegation or PDAs to fill orders without proper authorization? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Cross-Order Token Theft] Can an attacker exploit PDA derivations to fill one order but extract tokens from a different order's escrow? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [System Program Manipulation] Can an attacker replace the system_program account to intercept SOL transfers during fee distributions? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Associated Token Program Manipulation] Can an attacker replace the associated_token_program to create malicious ATAs during fill operations? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [OrderConfig Tampering] Can an attacker provide a modified OrderConfig struct that doesn't match the original order hash, causing incorrect fee and amount calculations? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Double Fill Attack] Can an attacker fill the same order multiple times by exploiting missing nonce or state tracking, draining escrow beyond the original src_amount? (Critical)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [ID Collision] Can an attacker create multiple orders with the same id field from the same maker, causing order hash collisions that overwrite existing orders in escrow PDAs? (Critical)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Source Amount Overflow] Can an attacker set src_amount to u64::MAX, causing arithmetic operations during fills to overflow and produce incorrect token distributions? (Critical)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Min Dst Amount Underflow] Can an attacker set min_dst_amount to 0, allowing fills with zero destination tokens and enabling complete theft of src tokens without payment? (Critical)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Estimated vs Min Amount Manipulation] Can an attacker set estimated_dst_amount < min_dst_amount to bypass the InvalidEstimatedTakingAmount error and create malicious orders? (High)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Expiration Time Zero] Can an attacker set expiration_time to 0 to create orders that are immediately expired, locking tokens in escrow without any fill opportunity? (Medium)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Native Asset Flag Inconsistency] Can an attacker set both src_asset_is_native and dst_asset_is_native to true to create SOL-to-SOL swaps that break protocol assumptions and cause double wrapping/unwrapping exploits? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Protocol Fee Overflow] Can an attacker set protocol_fee to u16::MAX (65535 basis points, or 65.535%), causing fee calculations to extract more than intended from order proceeds? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Integrator Fee Overflow] Can an attacker set integrator_fee to u16::MAX to cause fee calculations to overflow when combined with protocol_fee, extracting more than 100% of order value? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Total Fee Exceeds 100%] Can an attacker set protocol_fee + integrator_fee > 100000 basis points to extract more than the entire order value in fees? (Critical)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Surplus Percentage Overflow] Can an attacker set surplus_percentage to u8::MAX (255, representing 255%), causing surplus fee calculations to extract more than the entire surplus amount? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Max Cancellation Premium Exploit] Can an attacker set max_cancellation_premium to u64::MAX to force resolvers to pay exorbitant cancellation fees, creating permanent DoS on order cancellations? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Zero Fee Exploitation] Can an attacker set all fees (protocol_fee, integrator_fee, surplus_percentage) to 0 to avoid all protocol revenue sharing and undermine the protocol's economic model? (Medium)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Start Time in Past] Can an attacker set start_time to a past timestamp to manipulate auction rate calculations and get better fill rates than intended? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Start Time in Future] Can an attacker set start_time far in the future to delay auction start and prevent fills until the order expires? (Medium)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Duration Zero] Can an attacker set duration to 0 to cause division by zero in rate calculations or bypass auction mechanics entirely? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Duration Overflow] Can an attacker set duration to u32::MAX to cause timestamp calculations (start_time + duration) to overflow when checking auction completion? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Initial Rate Bump Zero] Can an attacker set initial_rate_bump to 0 to start the auction with no rate improvement, potentially locking orders at unfavorable rates? (Medium)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Initial Rate Bump Maximum] Can an attacker set initial_rate_bump to u16::MAX to cause rate calculations to overflow when multiplied with token amounts during fills? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Empty Points Vector] Can an attacker provide an empty points_and_time_deltas vector to bypass piecewise linear auction mechanics and lock the rate at initial_rate_bump? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Oversized Points Vector] Can an attacker provide a points_and_time_deltas vector with thousands of elements to cause DoS through compute unit exhaustion during rate calculations? (Medium)",
  "[File: idl/fusion_swap.json] [Type: PointAndTimeDelta] [Rate Bump Decrease] Can an attacker provide points_and_time_deltas with decreasing rate_bump values to create a reverse auction where rates get worse over time, manipulating fill economics? (High)",
  "[File: idl/fusion_swap.json] [Type: PointAndTimeDelta] [Time Delta Zero] Can an attacker set time_delta to 0 in points to create instantaneous rate jumps that break piecewise linear interpolation? (Medium)",
  "[File: idl/fusion_swap.json] [Type: PointAndTimeDelta] [Time Delta Sum Overflow] Can an attacker craft points where the cumulative sum of time_delta values exceeds duration or u32::MAX, causing timestamp overflow in rate calculations? (High)",
  "[File: idl/fusion_swap.json] [Type: PointAndTimeDelta] [Rate Bump Overflow] Can an attacker set rate_bump to u16::MAX in multiple points to cause cumulative rate bump additions to overflow during multi-point interpolation? (High)",
  "[File: idl/fusion_swap.json] [Type: ResolverAccess] [Bump Collision] Can an attacker manipulate the bump value in ResolverAccess to create PDA collisions that allow impersonation of legitimate resolvers? (Critical)",
  "[File: idl/fusion_swap.json] [Type: ResolverAccess] [Fake Resolver Account] Can an attacker create a fake ResolverAccess account with discriminator [32, 2, 74, 248, 174, 108, 70, 156] that isn't validated against the whitelist program? (Critical)",
  "[File: idl/fusion_swap.json] [Error: InconsistentNativeSrcTrait] Can an attacker bypass error code 6000 by providing src_asset_is_native that mismatches the actual src_mint type, exploiting missing validation to create malformed orders? (High)",
  "[File: idl/fusion_swap.json] [Error: InconsistentNativeDstTrait] Can an attacker bypass error code 6001 by providing dst_asset_is_native that mismatches the actual dst_mint type, enabling SOL wrapping exploits during fills? (High)",
  "[File: idl/fusion_swap.json] [Error: InvalidAmount] Can an attacker bypass error code 6002 by providing edge case amounts (0, 1, u64::MAX-1) that pass validation but break protocol invariants during transfers? (High)",
  "[File: idl/fusion_swap.json] [Error: MissingMakerDstAta] Can an attacker cause error code 6003 to be incorrectly triggered for native SOL orders, causing legitimate fills to fail and creating DoS? (Medium)",
  "[File: idl/fusion_swap.json] [Error: NotEnoughTokensInEscrow] Can an attacker bypass error code 6004 by exploiting race conditions in partial fills that allow extracting more tokens than available in escrow? (Critical)",
  "[File: idl/fusion_swap.json] [Error: OrderExpired] Can an attacker bypass error code 6005 by manipulating the clock sysvar or exploiting missing timestamp validation to fill expired orders? (High)",
  "[File:\n\n### Citations\n\n**File:** idl/fusion_swap.json (L1-1266)\n```json\n{",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [PDA Collision] Can an attacker craft a malicious order_hash argument that collides with the escrow PDA seeds (escrow + maker + order_hash) to cancel another user's order, leading to unauthorized token extraction from victim's escrow? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Access Control Bypass] Does the cancel instruction validate that the maker signer actually owns the escrow PDA, or can an attacker pass a valid maker signature with a manipulated order_hash to drain arbitrary escrows? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Token Theft] Can an attacker exploit the optional maker_src_ata account to redirect refunded tokens to a different account by manipulating the PDA derivation seeds, bypassing the intended maker's ATA? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Native SOL Handling] If order_src_asset_is_native is true, can an attacker exploit the SOL unwrapping logic by providing a false value to extract WSOL tokens instead of native SOL, causing fund loss or accounting errors? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Native SOL Handling] Can an attacker set order_src_asset_is_native to false when it should be true, preventing proper SOL unwrapping and locking funds permanently in WSOL form in the escrow? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [PDA Validation] Does the escrow PDA derivation (seeds: 'escrow', maker, order_hash) properly validate the order_hash length (32 bytes), or can an attacker pass truncated/padded hashes to create PDA collisions? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Account Substitution] Can an attacker substitute the src_mint account with a different token mint that has the same address as the original, causing the escrow_src_ata PDA to resolve to a different account and drain wrong tokens? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Token Program Manipulation] Can an attacker provide a malicious src_token_program account instead of the legitimate SPL Token program to bypass transfer checks and extract tokens without proper validation? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [ATA PDA Collision] Can an attacker exploit the escrow_src_ata PDA derivation (seeds: escrow, src_token_program, src_mint) by manipulating the token program address to access a different ATA containing more valuable tokens? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Optional Account Exploit] Since maker_src_ata is optional, can an attacker call cancel without providing this account when order_src_asset_is_native is false, causing tokens to be locked or sent to an unintended destination? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Reentrancy] Can an attacker create a malicious token program that calls back into the cancel instruction during the token transfer, allowing double-spending or state corruption before escrow closure? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [State Corruption] If cancel is called on a partially filled order, does the instruction properly handle the remaining balance, or can an attacker drain more tokens than their escrow balance by exploiting missing balance checks? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Signature Verification] Can an attacker bypass the maker signer requirement by exploiting the account constraint validation, potentially cancelling orders without proper authorization? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [Escrow Closure Bypass] Can an attacker prevent escrow account closure by manipulating the account state, leaving orphaned escrow accounts that lock funds indefinitely? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel] [ATA Creation Exploit] If maker_src_ata doesn't exist and is optional, can an attacker exploit the missing account to cause the instruction to fail repeatedly, creating a permanent DoS on order cancellation? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Access Control Bypass] Can an attacker create a fake resolver_access PDA with seeds ('resolver_access', attacker_address) that passes validation without proper whitelist program verification, allowing unauthorized order cancellation? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [PDA Collision] Can an attacker manipulate the resolver_access PDA seeds to collide with a legitimate resolver's access account, impersonating a whitelisted resolver to cancel orders and collect premiums? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Cross-Program Invocation] Does the resolver_access PDA properly validate that it belongs to the whitelist program (address: 46r3AXfEv6QxHhfFw848oK87bV6axq6YnVJrmvhkXe5d), or can an attacker provide a fake PDA from a malicious program? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Fee Manipulation] Can a malicious resolver exploit the reward_limit parameter in cancel_by_resolver to extract more cancellation premium than max_cancellation_premium specified in the OrderConfig's FeeConfig, draining maker funds? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Fee Calculation Overflow] Can an attacker craft an OrderConfig with extreme max_cancellation_premium values that cause integer overflow when calculating the actual premium to pay the resolver, leading to incorrect fee distribution? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Expiration Bypass] Can a resolver cancel an order before expiration by exploiting missing expiration validation, collecting premiums on orders that should still be fillable by other resolvers? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Premium Theft] Can an attacker provide a manipulated reward_limit that's higher than the actual cancellation premium calculation, extracting more SOL from the maker account than intended? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Account Substitution] Can an attacker substitute the maker account with a different address to redirect cancellation premium payments to themselves instead of the legitimate resolver? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Maker Receiver Manipulation] Can an attacker manipulate the maker_receiver account to redirect refunded tokens to a different address than the maker's intended receiver, stealing order funds? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Optional Fee Account Exploit] Can an attacker exploit the optional protocol_dst_acc and integrator_dst_acc accounts by omitting them when they should be present (based on FeeConfig), avoiding fee payments and stealing protocol revenue? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Fee Config Inconsistency] Can an attacker craft an OrderConfig with protocol_fee > 0 but omit protocol_dst_acc, bypassing the InconsistentProtocolFeeConfig error check to avoid paying protocol fees? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Integrator Fee Bypass] Can an attacker craft an OrderConfig with integrator_fee > 0 but omit integrator_dst_acc, bypassing the InconsistentIntegratorFeeConfig error check to steal integrator fees? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Native Asset Confusion] Can an attacker provide inconsistent src_mint and dst_mint with the order's src_asset_is_native and dst_asset_is_native flags in OrderConfig to exploit SOL wrapping/unwrapping logic? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Escrow Balance Exploit] Can an attacker cancel an order with escrow_src_ata containing more tokens than the original src_amount, extracting the excess tokens during cancellation without proper accounting? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Resolver Signature Bypass] Can an attacker bypass the resolver signer requirement by exploiting account delegation or proxy patterns to cancel orders without proper resolver authorization? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [OrderConfig Manipulation] Can an attacker provide a modified OrderConfig struct with altered fee parameters that differ from the original order, causing incorrect fee calculations during cancellation? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Time Manipulation] Can an attacker exploit the cancellation_auction_duration field in OrderConfig by setting it to extreme values (0 or u32::MAX) to manipulate premium calculations? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [ATA Validation Bypass] Since maker_src_ata is optional, can an attacker cancel native SOL orders without providing the maker's SOL ATA, causing funds to be lost or sent to system program? (High)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [Forbidden Cancellation Bypass] Can an attacker bypass the CancelOrderByResolverIsForbidden error check by manipulating the order expiration time or cancellation_auction_duration to cancel orders that should be maker-only cancellable? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: cancel_by_resolver] [System Program Exploit] Can an attacker replace the system_program account with a malicious program to intercept SOL transfers during premium payments and redirect funds? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Token Theft] Can an attacker create an order with src_amount set to 0 or u64::MAX, bypassing amount validation to create malicious orders that break protocol invariants or enable token theft during fills? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [PDA Collision] Can an attacker craft multiple orders with different parameters but the same PDA derivation (escrow seeds: 'escrow', maker, order_hash), causing escrow account collisions that overwrite existing orders and steal locked tokens? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Escrow Authority Exploit] Can an attacker manipulate the escrow PDA to become the authority for an ATA containing tokens from a different user's order, enabling cross-order token theft? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [ATA Creation Exploit] Can an attacker exploit the associated_token_program to create the escrow_src_ata for a different escrow PDA, redirecting token locks to unauthorized accounts? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Amount Validation Bypass] Can an attacker create an order with min_dst_amount > estimated_dst_amount, causing the InvalidEstimatedTakingAmount error to be bypassable and enabling unfillable orders that lock tokens indefinitely? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Fee Overflow] Can an attacker craft a FeeConfig with protocol_fee + integrator_fee > 100000 basis points (100%), causing fee calculations to overflow and extract more than 100% of order value? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Surplus Fee Exploit] Can an attacker set FeeConfig.surplus_percentage > 100 (basis points where BASE_1E2 = 100%), causing the protocol to take more than 100% of surplus during fills, draining resolver profits? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Max Cancellation Premium Manipulation] Can an attacker set FeeConfig.max_cancellation_premium to u64::MAX, forcing resolvers to pay exorbitant premiums for cancellation and creating permanent order locks? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Expiration Time Manipulation] Can an attacker set OrderConfig.expiration_time to 0 or in the past, creating immediately expired orders that lock tokens in escrow without any fill window? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Expiration Overflow] Can an attacker set OrderConfig.expiration_time to u32::MAX, creating orders that never expire and lock tokens indefinitely if maker loses access to their account? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Native Asset Flag Mismatch] Can an attacker create an order with src_asset_is_native set to true but provide a non-WSOL mint as src_mint, causing inconsistent native asset handling during cancellation or fills? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Destination Asset Confusion] Can an attacker set dst_asset_is_native to true but provide protocol_dst_acc and integrator_dst_acc accounts that don't match SOL's WSOL mint, bypassing fee validations? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Token Program Substitution] Can an attacker provide a malicious src_token_program that mimics SPL Token but has backdoors, allowing unauthorized token extraction from escrow after order creation? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Maker Receiver Manipulation] Can an attacker set maker_receiver to an arbitrary address they control instead of their own wallet, redirecting all filled order proceeds to the attacker's account? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Optional ATA Exploit] Since maker_src_ata is optional, can an attacker create native SOL orders without providing their SOL ATA, causing SOL wrapping to fail and locking native SOL in an inaccessible state? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Protocol Fee Account Validation] Can an attacker provide a protocol_dst_acc that isn't the legitimate protocol treasury, redirecting protocol fees to their own account during order fills? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Integrator Fee Theft] Can an attacker provide an integrator_dst_acc they control instead of the legitimate integrator, stealing integrator fees from all fills of their order? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Fee Account Consistency] Can an attacker create an order with protocol_fee = 0 but still provide protocol_dst_acc, potentially exploiting the InconsistentProtocolFeeConfig validation to create malformed orders? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Integrator Fee Consistency] Can an attacker create an order with integrator_fee = 0 but still provide integrator_dst_acc, potentially exploiting the InconsistentIntegratorFeeConfig validation to create malformed orders? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [AuctionData Manipulation] Can an attacker craft AuctionData with start_time in the past or future, causing auction rate calculations to overflow or underflow during fills? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Auction Duration Exploit] Can an attacker set AuctionData.duration to 0 or u32::MAX, causing division by zero or timestamp overflow in rate bump calculations during order fills? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Initial Rate Bump Overflow] Can an attacker set AuctionData.initial_rate_bump to u16::MAX, causing rate calculations to overflow when multiplied with amounts during fill operations? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Points Vector Exploit] Can an attacker provide an empty or excessively large points_and_time_deltas vector in AuctionData, causing DoS through compute unit exhaustion or bypassing auction mechanics? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Rate Bump Monotonicity] Can an attacker craft points_and_time_deltas with non-monotonic rate_bump values, causing rate calculations to decrease over time instead of increase, enabling auction manipulation? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Time Delta Overflow] Can an attacker set PointAndTimeDelta.time_delta values that sum to exceed u32::MAX or auction duration, causing timestamp calculations to overflow during fills? (High)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Cancellation Auction Duration] Can an attacker set cancellation_auction_duration > expiration_time, causing resolver cancellations to be enabled for longer than the order's lifetime and breaking the intended cancellation mechanics? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Order ID Collision] Can an attacker create multiple orders with the same OrderConfig.id from the same maker address, causing order hash collisions that overwrite existing escrows? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Token Lock Without Transfer] Can an attacker exploit the token transfer from maker_src_ata to escrow_src_ata to create an order without actually locking tokens, leaving escrow underfunded for subsequent fills? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [System Program Exploit] Can an attacker replace the system_program account with a malicious program to intercept escrow account creation and manipulate its initialization? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: create] [Associated Token Program Exploit] Can an attacker replace the associated_token_program with a malicious program to create fake ATAs that appear valid but have backdoor access? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Access Control Bypass] Can an attacker call fill without a valid resolver_access PDA by creating a fake PDA that isn't validated against the whitelist program, allowing unauthorized order filling? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Resolver Access PDA Forgery] Can an attacker forge a resolver_access PDA with seeds ('resolver_access', attacker_address) from a malicious program that isn't the whitelist program (address: 46r3A...), bypassing access control? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Amount Manipulation] Can an attacker provide an amount parameter that's greater than the remaining order balance in escrow_src_ata, extracting more tokens than available through insufficient balance checks? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Amount Underflow] Can an attacker provide amount = 0 to fill an order, bypassing amount validation and causing accounting errors or enabling repeated fills that drain escrow? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Partial Fill Exploit] Can an attacker partially fill an order with a manipulated amount that causes the remaining escrow balance to be insufficient for future fills, creating permanent order locks? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Rate Calculation Overflow] Can an attacker fill an order at a time when the auction rate bump calculation overflows (start_time + duration + time deltas), causing incorrect dst_amount calculations that result in token theft? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Expiration Bypass] Can an attacker fill an expired order by exploiting missing expiration validation, or by manipulating the clock sysvar to make an expired order appear valid? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Maker Receiver Substitution] Can an attacker substitute the maker_receiver account with their own address to redirect dst tokens that should go to the maker, stealing order proceeds? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Taker Source ATA Exploit] Can an attacker provide a taker_src_ata that belongs to a different owner, causing src tokens from escrow to be sent to a victim's account without consuming the attacker's tokens? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Token Program Mismatch] Can an attacker provide different src_token_program and dst_token_program accounts that aren't the legitimate SPL Token programs, bypassing transfer validations? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [ATA Creation Exploit] Can an attacker exploit the optional maker_dst_ata or taker_dst_ata accounts by causing the associated_token_program to create ATAs with incorrect ownership or mint? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Missing Maker DST ATA] If maker_dst_ata is optional and not provided, can an attacker cause the MissingMakerDstAta error to be bypassed when dst_asset_is_native is false, losing maker's dst tokens? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Missing Taker DST ATA] If taker_dst_ata is optional and not provided, can an attacker cause the MissingTakerDstAta error to be bypassed, receiving surplus or fee distributions they shouldn't receive? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Protocol Fee Manipulation] Can an attacker manipulate the OrderConfig.fee.protocol_fee calculation by providing extreme amount values that cause the fee to underflow or overflow? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Integrator Fee Manipulation] Can an attacker manipulate the OrderConfig.fee.integrator_fee calculation to pay less than required or overflow the fee calculation to extract protocol value? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Surplus Fee Bypass] Can an attacker manipulate the OrderConfig.fee.surplus_percentage calculation by providing an amount that results in negative or zero surplus, bypassing surplus fee payments? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Protocol Destination Account Exploit] Can an attacker exploit the optional protocol_dst_acc by omitting it when protocol_fee > 0, avoiding protocol fee payments and stealing protocol revenue? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Integrator Destination Account Exploit] Can an attacker exploit the optional integrator_dst_acc by omitting it when integrator_fee > 0, avoiding integrator fee payments? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Fee Distribution Precision Loss] Can an attacker exploit rounding errors in fee calculations (protocol_fee + integrator_fee + surplus_fee) to retain dust amounts that accumulate to significant value over many fills? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Native SOL Wrapping Exploit] If src_asset_is_native is true, can an attacker exploit the SOL unwrapping process to extract more native SOL than they deposited in WSOL? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Native DST SOL Unwrapping] If dst_asset_is_native is true, can an attacker manipulate the SOL unwrapping to the maker to cause the wrapped SOL to remain locked without proper conversion to native SOL? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Escrow Closure Exploit] After a full fill, can an attacker prevent escrow account closure to cause rent exemption refunds to be lost or misdirected? (Medium)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Escrow Balance Inconsistency] Can an attacker fill an order when escrow_src_ata has more tokens than the order's src_amount, extracting the excess tokens without proper accounting? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Auction Start Time Manipulation] Can an attacker fill an order before the auction's start_time by exploiting missing validation, getting better rates than intended? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Rate Bump Calculation Exploit] Can an attacker exploit the piecewise linear rate bump calculation (initial_rate_bump + points_and_time_deltas) to fill orders at manipulated rates that don't match the intended auction curve? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Time Delta Overflow in Fill] Can an attacker fill an order at a time when the cumulative time_delta calculations overflow, causing the rate bump to wrap around and provide advantageous rates? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Min Dst Amount Bypass] Can an attacker fill an order with a calculated dst_amount less than OrderConfig.min_dst_amount by exploiting insufficient validation, causing maker to receive less than minimum? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Estimated Dst Amount Exploitation] Can an attacker craft fills that exploit the relationship between estimated_dst_amount and actual calculated dst_amount to manipulate surplus calculations? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Maker Account Drain] Can an attacker substitute the maker account to cause SOL rent payments or fee distributions to drain a victim's wallet instead of the legitimate maker? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Taker Signature Bypass] Can an attacker bypass the taker signer requirement through account delegation or PDAs to fill orders without proper authorization? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Cross-Order Token Theft] Can an attacker exploit PDA derivations to fill one order but extract tokens from a different order's escrow? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [System Program Manipulation] Can an attacker replace the system_program account to intercept SOL transfers during fee distributions? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Associated Token Program Manipulation] Can an attacker replace the associated_token_program to create malicious ATAs during fill operations? (Critical)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [OrderConfig Tampering] Can an attacker provide a modified OrderConfig struct that doesn't match the original order hash, causing incorrect fee and amount calculations? (High)",
  "[File: idl/fusion_swap.json] [Instruction: fill] [Double Fill Attack] Can an attacker fill the same order multiple times by exploiting missing nonce or state tracking, draining escrow beyond the original src_amount? (Critical)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [ID Collision] Can an attacker create multiple orders with the same id field from the same maker, causing order hash collisions that overwrite existing orders in escrow PDAs? (Critical)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Source Amount Overflow] Can an attacker set src_amount to u64::MAX, causing arithmetic operations during fills to overflow and produce incorrect token distributions? (Critical)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Min Dst Amount Underflow] Can an attacker set min_dst_amount to 0, allowing fills with zero destination tokens and enabling complete theft of src tokens without payment? (Critical)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Estimated vs Min Amount Manipulation] Can an attacker set estimated_dst_amount < min_dst_amount to bypass the InvalidEstimatedTakingAmount error and create malicious orders? (High)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Expiration Time Zero] Can an attacker set expiration_time to 0 to create orders that are immediately expired, locking tokens in escrow without any fill opportunity? (Medium)",
  "[File: idl/fusion_swap.json] [Type: OrderConfig] [Native Asset Flag Inconsistency] Can an attacker set both src_asset_is_native and dst_asset_is_native to true to create SOL-to-SOL swaps that break protocol assumptions and cause double wrapping/unwrapping exploits? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Protocol Fee Overflow] Can an attacker set protocol_fee to u16::MAX (65535 basis points, or 65.535%), causing fee calculations to extract more than intended from order proceeds? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Integrator Fee Overflow] Can an attacker set integrator_fee to u16::MAX to cause fee calculations to overflow when combined with protocol_fee, extracting more than 100% of order value? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Total Fee Exceeds 100%] Can an attacker set protocol_fee + integrator_fee > 100000 basis points to extract more than the entire order value in fees? (Critical)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Surplus Percentage Overflow] Can an attacker set surplus_percentage to u8::MAX (255, representing 255%), causing surplus fee calculations to extract more than the entire surplus amount? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Max Cancellation Premium Exploit] Can an attacker set max_cancellation_premium to u64::MAX to force resolvers to pay exorbitant cancellation fees, creating permanent DoS on order cancellations? (High)",
  "[File: idl/fusion_swap.json] [Type: FeeConfig] [Zero Fee Exploitation] Can an attacker set all fees (protocol_fee, integrator_fee, surplus_percentage) to 0 to avoid all protocol revenue sharing and undermine the protocol's economic model? (Medium)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Start Time in Past] Can an attacker set start_time to a past timestamp to manipulate auction rate calculations and get better fill rates than intended? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Start Time in Future] Can an attacker set start_time far in the future to delay auction start and prevent fills until the order expires? (Medium)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Duration Zero] Can an attacker set duration to 0 to cause division by zero in rate calculations or bypass auction mechanics entirely? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Duration Overflow] Can an attacker set duration to u32::MAX to cause timestamp calculations (start_time + duration) to overflow when checking auction completion? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Initial Rate Bump Zero] Can an attacker set initial_rate_bump to 0 to start the auction with no rate improvement, potentially locking orders at unfavorable rates? (Medium)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Initial Rate Bump Maximum] Can an attacker set initial_rate_bump to u16::MAX to cause rate calculations to overflow when multiplied with token amounts during fills? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Empty Points Vector] Can an attacker provide an empty points_and_time_deltas vector to bypass piecewise linear auction mechanics and lock the rate at initial_rate_bump? (High)",
  "[File: idl/fusion_swap.json] [Type: AuctionData] [Oversized Points Vector] Can an attacker provide a points_and_time_deltas vector with thousands of elements to cause DoS through compute unit exhaustion during rate calculations? (Medium)",
  "[File: idl/fusion_swap.json] [Type: PointAndTimeDelta] [Rate Bump Decrease] Can an attacker provide points_and_time_deltas with decreasing rate_bump values to create a reverse auction where rates get worse over time, manipulating fill economics? (High)",
  "[File: idl/fusion_swap.json] [Type: PointAndTimeDelta] [Time Delta Zero] Can an attacker set time_delta to 0 in points to create instantaneous rate jumps that break piecewise linear interpolation? (Medium)",
  "[File: idl/fusion_swap.json] [Type: PointAndTimeDelta] [Time Delta Sum Overflow] Can an attacker craft points where the cumulative sum of time_delta values exceeds duration or u32::MAX, causing timestamp overflow in rate calculations? (High)",
  "[File: idl/fusion_swap.json] [Type: PointAndTimeDelta] [Rate Bump Overflow] Can an attacker set rate_bump to u16::MAX in multiple points to cause cumulative rate bump additions to overflow during multi-point interpolation? (High)",
  "[File: idl/fusion_swap.json] [Type: ResolverAccess] [Bump Collision] Can an attacker manipulate the bump value in ResolverAccess to create PDA collisions that allow impersonation of legitimate resolvers? (Critical)",
  "[File: idl/fusion_swap.json] [Type: ResolverAccess] [Fake Resolver Account] Can an attacker create a fake ResolverAccess account with discriminator [32, 2, 74, 248, 174, 108, 70, 156] that isn't validated against the whitelist program? (Critical)",
  "[File: idl/fusion_swap.json] [Error: InconsistentNativeSrcTrait] Can an attacker bypass error code 6000 by providing src_asset_is_native that mismatches the actual src_mint type, exploiting missing validation to create malformed orders? (High)",
  "[File: idl/fusion_swap.json] [Error: InconsistentNativeDstTrait] Can an attacker bypass error code 6001 by providing dst_asset_is_native that mismatches the actual dst_mint type, enabling SOL wrapping exploits during fills? (High)",
  "[File: idl/fusion_swap.json] [Error: InvalidAmount] Can an attacker bypass error code 6002 by providing edge case amounts (0, 1, u64::MAX-1) that pass validation but break protocol invariants during transfers? (High)",
  "[File: idl/fusion_swap.json] [Error: MissingMakerDstAta] Can an attacker cause error code 6003 to be incorrectly triggered for native SOL orders, causing legitimate fills to fail and creating DoS? (Medium)",
  "[File: idl/fusion_swap.json] [Error: NotEnoughTokensInEscrow] Can an attacker bypass error code 6004 by exploiting race conditions in partial fills that allow extracting more tokens than available in escrow? (Critical)",
  "[File: idl/fusion_swap.json] [Error: OrderExpired] Can an attacker bypass error code 6005 by manipulating the clock sysvar or exploiting missing timestamp validation to fill expired orders? (High)",
  "[File:\n\n### Citations\n\n**File:** idl/fusion_swap.json (L1-1266)\n```json\n{",
  "[File: idl/whitelist.json] [Function: initialize] [Reinitialization Attack] Can an attacker call initialize() multiple times if the whitelist_state PDA already exists, potentially overwriting the authority and taking control of the whitelist system? (Critical)",
  "[File: idl/whitelist.json] [Function: initialize] [Authority Hijacking] Does the initialize instruction properly validate that whitelist_state hasn't been initialized before, or can an attacker front-run the legitimate initialization to set themselves as the authority? (Critical)",
  "[File: idl/whitelist.json] [Function: initialize] [PDA Collision] Can an attacker exploit the deterministic PDA derivation of whitelist_state (seeds: 'whitelist_state') to predict the account address and pre-fund it with malicious data before initialization? (High)",
  "[File: idl/whitelist.json] [Function: initialize] [Missing Rent Exemption Check] Does the initialize instruction ensure the whitelist_state account is rent-exempt, or can an attacker cause the account to be reclaimed by creating it with insufficient lamports? (Medium)",
  "[File: idl/whitelist.json] [Function: initialize] [Account Size Validation] Can an attacker manipulate the account creation to allocate insufficient space for WhitelistState, causing future operations to fail or corrupt state? (Medium)",
  "[File: idl/whitelist.json] [Function: initialize] [System Program Validation] Is the system_program address (11111111111111111111111111111111) hardcoded correctly, or can an attacker substitute a malicious program during initialization? (High)",
  "[File: idl/whitelist.json] [Function: initialize] [Authority Persistence] After initialization, is the authority field in WhitelistState immutable except through set_authority, or can it be modified through unintended paths? (High)",
  "[File: idl/whitelist.json] [Function: initialize] [Discriminator Collision] Can an attacker create an account with the same discriminator [175, 175, 109, 31, 13, 152, 155, 237] to impersonate a legitimately initialized whitelist_state? (High)",
  "[File: idl/whitelist.json] [Function: initialize] [Concurrent Initialization] If multiple transactions attempt to initialize the whitelist simultaneously, can this lead to race conditions or undefined state? (Medium)",
  "[File: idl/whitelist.json] [Function: initialize] [Missing Signer Validation] Does the instruction properly verify that the authority account is a signer, or can an unsigned account be passed as authority? (Critical)",
  "[File: idl/whitelist.json] [Function: register] [Unauthorized Registration] Can a non-authority user call register() by providing their own public key as the authority parameter, bypassing access control and adding themselves to the whitelist? (Critical)",
  "[File: idl/whitelist.json] [Function: register] [Authority Validation Bypass] Does register properly verify that the authority signer matches the authority stored in whitelist_state, or can an attacker sign with any account and register arbitrary resolvers? (Critical)",
  "[File: idl/whitelist.json] [Function: register] [PDA Collision Attack] Can an attacker manipulate the _user parameter to create a resolver_access PDA that collides with an existing account, potentially corrupting state or enabling unauthorized access? (High)",
  "[File: idl/whitelist.json] [Function: register] [Duplicate Registration] Can an attacker call register() multiple times for the same user to create duplicate resolver_access PDAs, causing state inconsistency or resource exhaustion? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Resolver Access Overwrite] If resolver_access PDA already exists for a user, does register fail properly, or can it overwrite existing access data including the bump seed? (High)",
  "[File: idl/whitelist.json] [Function: register] [Bump Seed Manipulation] Can an attacker exploit the bump field in ResolverAccess (u8) by providing a crafted user pubkey that generates a predictable bump, enabling PDA prediction attacks? (High)",
  "[File: idl/whitelist.json] [Function: register] [Cross-Program Invocation] When register creates the resolver_access PDA, can a malicious program intercept the CPI to the system program and substitute malicious account data? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Account Ownership Validation] Does register verify that the created resolver_access account is owned by the whitelist program, or can an attacker provide a pre-existing account owned by another program? (High)",
  "[File: idl/whitelist.json] [Function: register] [Self-Registration] Can the authority register themselves as a resolver, and if so, does this create a conflict of interest or enable privilege escalation attacks? (Low)",
  "[File: idl/whitelist.json] [Function: register] [Seed Injection Attack] Can an attacker craft a user pubkey that, when combined with the 'resolver_access' seed, produces a PDA that collides with critical protocol accounts? (High)",
  "[File: idl/whitelist.json] [Function: register] [Whitelist State Validation] Does register properly validate that whitelist_state is initialized before allowing registration, or can it be called with an uninitialized state account? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Discriminator Verification] Can an attacker provide a fake whitelist_state account with the correct discriminator [246, 118, 44, 60, 71, 37, 201, 55] but malicious authority data? (High)",
  "[File: idl/whitelist.json] [Function: register] [Rent Exemption] Does register ensure resolver_access is created with sufficient lamports for rent exemption, or can the account be reclaimed causing resolver access loss? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Authority Lamport Drain] Since authority is marked writable, can an attacker exploit register to drain lamports from the authority account through excessive registrations? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Zero Address Registration] Can an attacker register the zero address (11111111111111111111111111111111) or other system accounts as resolvers, causing undefined behavior? (High)",
  "[File: idl/whitelist.json] [Function: register] [Program ID Registration] Can an attacker register program IDs as resolvers, enabling cross-program attacks or CPI exploits in the fusion-swap program? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Batch Registration DoS] Can an attacker force the authority to register thousands of fake resolvers, exhausting compute units or storage to DoS legitimate resolver operations? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Missing Initialization Check] Does register verify that resolver_access doesn't already exist, or can it be called repeatedly causing account reinitialization vulnerabilities? (High)",
  "[File: idl/whitelist.json] [Function: register] [Account Size Exploitation] Can an attacker manipulate account size during resolver_access creation to allocate excessive space, draining authority lamports through rent requirements? (Low)",
  "[File: idl/whitelist.json] [Function: register] [PDA Bump Exhaustion] If the bump seed derivation fails for a specific user pubkey, does register handle this gracefully, or can it cause transaction failures exploitable for DoS? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [Unauthorized Deregistration] Can a non-authority user call deregister() to remove legitimate resolvers from the whitelist, disrupting protocol operations and causing resolver access loss? (Critical)",
  "[File: idl/whitelist.json] [Function: deregister] [Authority Bypass] Does deregister properly validate that the signer matches the authority in whitelist_state, or can any user deregister any resolver by forging the authority signature? (Critical)",
  "[File: idl/whitelist.json] [Function: deregister] [Self-Deregistration Prevention] Can the authority accidentally or maliciously deregister themselves if they are also a resolver, locking themselves out of management functions? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [Resolver Access Deletion] When deregister closes the resolver_access account, are lamports properly returned to the authority, or can they be stolen by providing a malicious destination account? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [PDA Validation] Does deregister verify that the resolver_access account is derived from the correct seeds ('resolver_access' + user), or can an attacker provide a fake PDA? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Non-Existent Resolver] Can an attacker call deregister with a user that was never registered, potentially causing undefined behavior or transaction failures exploitable for DoS? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [Double Deregistration] Can deregister be called multiple times for the same user after the resolver_access account is closed, enabling lamport theft or state corruption? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Account Ownership Check] Does deregister verify that resolver_access is owned by the whitelist program before closing, or can it close accounts owned by other programs? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Discriminator Validation] Does deregister check that resolver_access has the correct discriminator [32, 2, 74, 248, 174, 108, 70, 156], or can an attacker provide any account with the correct PDA derivation? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Lamport Destination] When resolver_access is closed, does the instruction hardcode the lamport recipient as authority, or can an attacker redirect funds to an arbitrary account? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Concurrent Deregistration] If multiple deregister transactions target the same resolver simultaneously, can this cause race conditions or double-spending of lamports? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Active Order Check] Does deregister verify that the resolver has no active orders in fusion-swap before removal, or can deregistration strand orders mid-execution? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Whitelist State Validation] Does deregister properly validate that whitelist_state is initialized and matches the expected PDA, or can it operate on a fake state account? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Authority Writable Exploit] Since authority is marked writable, can an attacker exploit deregister to modify authority account state beyond intended lamport returns? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Resolver Access Writable] Since resolver_access is marked writable, can an attacker exploit this to corrupt the account data before it's closed, affecting other protocol operations? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [System Program Substitution] Can an attacker provide a fake system program address instead of 11111111111111111111111111111111 to prevent proper account closure? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Bump Validation] Does deregister verify that the bump field in resolver_access matches the expected bump from PDA derivation, or can an attacker provide an account with an incorrect bump? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Account Data Residue] After resolver_access is closed, does any data remain accessible that could leak sensitive information or enable reinitialization attacks? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [Griefing Attack] Can a malicious authority repeatedly register and deregister resolvers to cause gas exhaustion or disrupt resolver operations through state churn? (Low)",
  "[File: idl/whitelist.json] [Function: set_authority] [Authority Validation Bypass] Does set_authority properly verify that current_authority matches the authority stored in whitelist_state, or can any user become the new authority? (Critical)",
  "[File: idl/whitelist.json] [Function: set_authority] [Permanent Authority Loss] If set_authority sets new_authority to an uncontrolled address (e.g., zero address, burn address), does it validate against this, or can the whitelist become permanently unmanageable? (Critical)",
  "[File: idl/whitelist.json] [Function: set_authority] [Front-Running Attack] Can an attacker monitor the mempool for set_authority transactions and front-run them to set themselves as the new authority before the legitimate transaction executes? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Authority Rotation DoS] Can the current authority repeatedly call set_authority in rapid succession, causing compute unit exhaustion or preventing other whitelist operations? (Low)",
  "[File: idl/whitelist.json] [Function: set_authority] [New Authority Validation] Does set_authority validate that new_authority is a valid public key and not a system program or invalid address? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [Whitelist State Corruption] Since whitelist_state is marked writable, can set_authority accidentally corrupt other state fields beyond the authority field during the update? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [PDA Validation] Does set_authority verify that whitelist_state is derived from the correct seed ('whitelist_state'), or can an attacker provide a fake state account? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Discriminator Check] Does set_authority validate that whitelist_state has the correct discriminator [246, 118, 44, 60, 71, 37, 201, 55], or can it operate on accounts with forged discriminators? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Atomic Authority Transfer] If set_authority fails mid-execution, can it leave the whitelist in a state where no authority is set, permanently bricking the protocol? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Same Authority Assignment] Can current_authority set new_authority to themselves, and if so, does this create unnecessary state writes or expose transaction replay vulnerabilities? (Low)",
  "[File: idl/whitelist.json] [Function: set_authority] [Authority Signer Validation] Is current_authority properly validated as a signer, or can an unsigned account be passed, enabling authority changes without proper authentication? (Critical)",
  "[File: idl/whitelist.json] [Function: set_authority] [Whitelist State Ownership] Does set_authority verify that whitelist_state is owned by the whitelist program, or can it modify accounts owned by malicious programs? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Account Writable Exploit] Since current_authority is marked writable, can an attacker exploit set_authority to drain lamports from the current authority account? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [Multiple Authority Transitions] Can an attacker chain multiple set_authority calls in a single transaction to perform complex authority manipulation attacks? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [New Authority Collision] Can an attacker set new_authority to an address that collides with existing resolver_access PDAs, causing authorization conflicts? (Low)",
  "[File: idl/whitelist.json] [Function: set_authority] [Event Emission] If set_authority doesn't emit an event, can authority changes go unnoticed, enabling stealth takeover attacks without off-chain detection? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [Reentrancy Guard] Can set_authority be called recursively through CPI, enabling reentrancy attacks that manipulate authority state mid-execution? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [State Initialization Check] Does set_authority verify that whitelist_state is initialized before allowing authority changes, or can it operate on uninitialized state? (Medium)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Authority Immutability] Can the authority field in WhitelistState be modified through memory manipulation or buffer overflow attacks, bypassing set_authority validation? (Critical)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Discriminator Forgery] Can an attacker create a fake account with discriminator [246, 118, 44, 60, 71, 37, 201, 55] that passes validation but contains malicious authority data? (High)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Struct Size] Is WhitelistState allocated with exactly 32 bytes for the authority pubkey, or can size mismatches cause deserialization errors or buffer overflows? (Medium)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Authority Zero Check] Does WhitelistState validate that authority is not the zero pubkey during initialization or updates, preventing permanent protocol lockout? (High)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [PDA Bump Storage] Should WhitelistState also store its own bump seed for verification, or does the absence of this field enable PDA collision attacks? (Medium)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Account Closure] Can WhitelistState be closed through system program calls, permanently destroying the whitelist and disabling all resolver access control? (Critical)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Bump Seed Range] Is the bump field in ResolverAccess properly constrained to valid bump values (0-255), or can it be set to invalid values causing PDA derivation failures? (Medium)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Discriminator Collision] Can an attacker create accounts with discriminator [32, 2, 74, 248, 174, 108, 70, 156] that pass as legitimate resolver_access accounts? (High)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Struct Minimal Data] Does ResolverAccess containing only a bump field (u8) provide sufficient information, or should it include additional metadata like registration timestamp or resolver status? (Low)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Memory Alignment] Can the single u8 bump field cause memory alignment issues or padding exploits during serialization/deserialization? (Low)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Account Reuse] After deregistration, can the resolver_access account address be reused for a different resolver, causing authorization confusion? (Medium)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Bump Modification] Can the bump field be modified after ResolverAccess creation, enabling attackers to manipulate PDA verification in fusion-swap operations? (High)",
  "[File: idl/whitelist.json] [PDA: whitelist_state] [Seed Collision] Can an attacker find alternative seed combinations that produce the same PDA as 'whitelist_state', enabling impersonation attacks? (High)",
  "[File: idl/whitelist.json] [PDA: whitelist_state] [Seed Hardcoding] Are the seed bytes [119, 104, 105, 116, 101, 108, 105, 115, 116, 95, 115, 116, 97, 116, 101] correctly encoding 'whitelist_state', or is there an encoding mismatch? (Medium)",
  "[File: idl/whitelist.json] [PDA: whitelist_state] [Canonical Bump] Does the protocol use the canonical bump (255 -> 0 search) for whitelist_state derivation, or can non-canonical bumps cause validation bypasses? (Medium)",
  "[File: idl/whitelist.json] [PDA: whitelist_state] [Cross-Program PDA] Can another program derive the same whitelist_state PDA and create it first, hijacking the whitelist initialization? (High)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [User Pubkey Manipulation] Can an attacker craft specific user pubkeys that, when combined with 'resolver_access' seed, produce PDAs that collide with critical system accounts? (High)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Seed Order] Are the seeds for resolver_access correctly ordered as ['resolver_access', user], or can seed order manipulation enable PDA prediction attacks? (Medium)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Bump Exhaustion] Can an attacker provide a user pubkey where no valid bump exists (0-255 exhausted), causing DoS for that specific resolver registration? (Low)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Seed Length] Are the seed bytes [114, 101, 115, 111, 108, 118, 101, 114, 95, 97, 99, 99, 101, 115, 115] correctly encoding 'resolver_access', or is there truncation/padding? (Medium)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Multi-Program Collision] Can resolver_access PDAs derived by the whitelist program collide with PDAs from other programs (like fusion-swap), causing authorization conflicts? (Medium)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Canonical Bump Validation] Does the protocol verify that the stored bump in ResolverAccess matches the canonical bump from derivation, preventing bump manipulation attacks? (High)",
  "[File: idl/whitelist.json] [CPI Security] [Fusion-Swap Integration] When fusion-swap calls whitelist through CPI to validate resolver access, can an attacker provide a fake whitelist program address to bypass authorization? (Critical)",
  "[File: idl/whitelist.json] [CPI Security] [Account Passing] Can fusion-swap pass incorrect resolver_access accounts to whitelist CPI calls, enabling unauthorized resolvers to fill orders? (Critical)",
  "[File: idl/whitelist.json] [CPI Security] [PDA Verification] Does the whitelist program verify that CPIs are coming from the legitimate fusion-swap program, or can malicious programs call whitelist functions? (High)",
  "[File: idl/whitelist.json] [CPI Security] [Reentrancy Attacks] Can a malicious program call whitelist instructions through CPI in a recursive manner, causing state corruption or compute unit exhaustion? (Medium)",
  "[File: idl/whitelist.json] [CPI Security] [System Program CPI] When whitelist instructions invoke the system program to create/close accounts, can an attacker intercept or manipulate these CPIs? (High)",
  "[File: idl/whitelist.json] [CPI Security] [Account Ownership Transfer] Can CPIs to whitelist change account ownership in unexpected ways, enabling account hijacking or state corruption? (High)",
  "[File: idl/whitelist.json] [CPI Security] [Instruction Discrimination] Does whitelist properly discriminate between direct calls and CPI calls, applying appropriate validation for each context? (Medium)",
  "[File: idl/whitelist.json] [CPI Security] [Program ID Validation] Does whitelist validate that the invoking program is authorized (e.g., fusion-swap), or can any program call whitelist instructions through CPI? (High)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Error Code Collision] Can error code 6000 (Unauthorized) collide with error codes from other programs, causing confusion in error handling or client applications? (Low)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Generic Error] Is the single 'Unauthorized' error sufficient, or should whitelist define more specific errors (e.g., InvalidAuthority, ResolverNotFound, AlreadyRegistered) for better debugging? (Low)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Error Propagation] When whitelist returns Unauthorized through CPI to fusion-swap, can this error be properly caught and handled, or does it cause transaction failures? (Medium)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Missing Errors] Are there missing error definitions for critical failure cases like DoubleInitialization, InvalidPDA, or AccountClosureFailed that could obscure security vulnerabilities? (Medium)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Error Message Leakage] Does the 'Unauthorized' error message leak sensitive information about whitelist state or authority addresses that could aid attackers? (Low)",
  "[File: idl/whitelist.json] [Discriminator: initialize] [Instruction Collision] Can the initialize discriminator [175, 175, 109, 31, 13, 152, 155, 237] collide with discriminators from other programs, causing unintended instruction execution? (High)",
  "[File: idl/whitelist.json] [Discriminator: register] [Discriminator Prediction] Can an attacker predict the register discriminator [211, 124, 67, 15, 211, 194, 178, 240] and craft malicious transactions that execute register with forged parameters? (Medium)",
  "[File: idl/whitelist.json] [Discriminator: deregister] [Instruction Spoofing] Can an attacker craft a transaction with the deregister discriminator [161, 178, 39, 189, 231, 224, 13, 187] that bypasses validation by appearing legitimate? (Medium)",
  "[File: idl/whitelist.json] [Discriminator: set_authority] [Discriminator Brute Force] Can an attacker brute-force instruction discriminators to find collisions with set_authority [133, 250, 37, 21, 110, 163, 26, 121], enabling unauthorized authority changes? (High)",
  "[File: idl/whitelist.json] [Discriminator: WhitelistState] [Account Type Confusion] Can an attacker create an account with WhitelistState discriminator [246, 118, 44, 60, 71, 37, 201, 55] that passes type checks but contains invalid data? (High)",
  "[File: idl/whitelist.json] [Discriminator: ResolverAccess] [Account Impersonation] Can an attacker create fake resolver_access accounts with discriminator [32, 2, 74, 248, 174, 108, 70, 156] to impersonate whitelisted resolvers? (Critical)",
  "[File: idl/whitelist.json] [Account Validation] [Authority Signer Check] Across all instructions, is the authority/current_authority account properly validated as a signer, or can unsigned accounts be passed? (Critical)",
  "[File: idl/whitelist.json] [Account Validation] [PDA Derivation Verification] Do all instructions that use PDAs (whitelist_state, resolver_access) verify the PDA is derived with correct seeds and bump, or can fake accounts be provided? (Critical)",
  "[File: idl/whitelist.json] [Account Validation] [Account Ownership] Do instructions validate that whitelist_state and resolver_access are owned by the whitelist program (5jzZhrzqkbdwp5d3J1XbmaXMRnqeXimM1mDMoGHyvR7S)? (High)",
  "[File: idl/whitelist.json] [Account Validation] [Writable Account Abuse] For accounts marked writable (authority, whitelist_state, resolver_access), can attackers exploit write permissions to corrupt data or drain lamports? (High)",
  "[File: idl/whitelist.json] [Account Validation] [System Program Validation] Is the system_program address (11111111111111111111111111111111) validated as the actual system program, or can a fake program be substituted? (High)",
  "[File: idl/whitelist.json] [Account Validation] [Account Initialization State] Do instructions check whether accounts are initialized before operating on them, preventing operations on uninitialized accounts? (High)",
  "[File: idl/whitelist.json] [Account Validation] [Account Size Verification] Do instructions verify that account sizes match expected sizes for WhitelistState and ResolverAccess, preventing buffer overflow or underflow? (Medium)",
  "[File: idl/whitelist.json] [Account Validation] [Account Discriminator Check] Do all instructions validate account discriminators before deserializing, preventing type confusion attacks? (High)",
  "[File: idl/whitelist.json] [State Transition] [Initialization -> Registration] Can register be called before initialize completes, causing undefined behavior or allowing registration without proper authority setup? (High)",
  "[File: idl/whitelist.json] [State Transition] [Registration -> Deregistration] Can a resolver be deregistered while they have active orders in fusion-swap, stranding tokens in escrow? (Medium)",
  "[File: idl/whitelist.json] [State Transition] [Authority Change -> Operations] After set_authority is called, are there race conditions where the old authority can still perform operations before state updates propagate? (Medium)",
  "[File: idl/whitelist.json] [State Transition] [Deregistration -> Re-registration] Can a deregistered resolver be immediately re-registered with the same user pubkey, and does this create security risks or state inconsistency? (Low)",
  "[File: idl/whitelist.json] [State Transition] [Concurrent Operations] If multiple instructions (register, deregister, set_authority) execute concurrently, can this cause race conditions or state corruption? (Medium)",
  "[File: idl/whitelist.json] [State Transition] [Atomic State Updates] Are state updates in whitelist_state and resolver_access atomic, or can partial updates occur during transaction failures? (High)",
  "[File: idl/whitelist.json] [Economic Attack] [Registration Cost] Does register require the authority to pay rent for resolver_access accounts, and can this be exploited to drain authority funds through mass registrations? (Medium)",
  "[File: idl/whitelist.json] [Economic Attack] [Deregistration Refund] When resolver_access is closed via deregister, are refunded lamports properly credited, or can they be stolen through refund manipulation? (High)",
  "[File: idl/whitelist.json] [Economic Attack] [Whitelist Griefing] Can an attacker force the authority to waste compute units by repeatedly triggering failed register/deregister operations? (Low)",
  "[File: idl/whitelist.json] [Economic Attack] [Resolver Bribery] Can resolvers bribe the authority to get registered, and does the whitelist design prevent such off-chain corruption? (Low)",
  "[File: idl/whitelist.json] [Fusion Integration] [Resolver Validation Bypass] When fusion-swap checks resolver authorization, can it bypass whitelist validation by directly checking resolver_access PDA existence without CPI? (Critical)",
  "[File: idl/whitelist.json] [Fusion Integration] [Account Passing] Can fusion-swap pass fake resolver_access accounts that aren't actually whitelisted but have the correct PDA structure? (Critical)",
  "[File: idl/whitelist.json] [Fusion Integration] [Authorization Timing] Is there a time gap between resolver registration and when they can fill orders, allowing unauthorized fills during registration? (Medium)",
  "[File: idl/whitelist.json] [Fusion Integration] [Resolver Revocation] If a resolver is deregistered mid-order-fill in fusion-swap, can this cause the fill transaction to fail, locking tokens in escrow? (Medium)",
  "[File: idl/whitelist.json] [Fusion Integration] [Cross-Program State] Can inconsistencies between whitelist state and fusion-swap state (e.g., resolver registered in whitelist but not active in fusion-swap) create exploits? (Medium)",
  "[File: idl/whitelist.json] [DoS] [Compute Unit Exhaustion] Can an attacker craft instructions with maximum account list lengths or complex PDA derivations to exhaust compute units and DoS the whitelist? (Medium)",
  "[File: idl/whitelist.json] [DoS] [Account Spam] Can an attacker register thousands of resolvers to spam resolver_access accounts, exhausting storage and making legitimate operations expensive? (Medium)",
  "[File: idl/whitelist.json] [DoS] [Transaction Flooding] Can an attacker flood the network with whitelist transactions to prevent legitimate registrations or authority changes? (Low)",
  "[File: idl/whitelist.json] [DoS] [PDA Derivation DoS] Can an attacker provide user pubkeys that require maximum iterations to find a valid bump, causing compute unit exhaustion during register? (Low)",
  "[File: idl/whitelist.json] [DoS] [Account Lock] Can an attacker lock critical accounts (whitelist_state, resolver_access) by creating long-running transactions that hold account write locks? (Low)",
  "[File: idl/whitelist.json] [Missing Feature] [Resolver Listing] Does the whitelist provide a way to query all registered resolvers, or can unauthorized resolvers claim to be whitelisted without verification? (Medium)",
  "[File: idl/whitelist.json] [Missing Feature] [Registration Timestamp] Does ResolverAccess store when a resolver was registered, and without this, can historical authorization disputes arise? (Low)",
  "[File: idl/whitelist.json] [Missing Feature] [Resolver Metadata] Should ResolverAccess include metadata like resolver name, status, or reputation score, and does the absence of this create security gaps? (Low)",
  "[File: idl/whitelist.json] [Missing Feature] [Temporary Suspension] Does the whitelist support temporarily suspending resolvers without full deregistration, and without this, can misbehaving resolvers continue operations? (Medium)",
  "[File: idl/whitelist.json] [Missing Feature] [Multi-Signature Authority] Does the whitelist support multi-sig authority, or is a single authority pubkey a single point of failure? (High)",
  "[File: idl/whitelist.json] [Missing Feature] [Authority Recovery] If the authority private key is lost, is there a recovery mechanism, or does the whitelist become permanently unmanageable? (High)",
  "[File: idl/whitelist.json] [Missing Feature] [Event Emission] Does the whitelist emit events for register, deregister, and set_authority operations, and without events, can off-chain systems track state changes? (Medium)",
  "[File: idl/whitelist.json] [Missing Feature] [Resolver Count] Does WhitelistState track the total number of registered resolvers, and without this, can resolver limits be enforced? (Low)",
  "[File: idl/whitelist.json] [Edge Case] [Empty Whitelist] Can fusion-swap operate when no resolvers are registered, and does this create a DoS vector if the authority deregisters all resolvers? (Medium)",
  "[File: idl/whitelist.json] [Edge Case] [Authority Change During Operations] If set_authority is called while resolvers are actively filling orders, can this cause authorization failures mid-transaction? (Medium)",
  "[File: idl/whitelist.json] [Edge Case] [Maximum Resolvers] Is there a limit on the number of resolvers that can be registered, and without limits, can storage exhaustion DoS the protocol? (Medium)",
  "[File: idl/whitelist.json] [Edge Case] [Zero Authority] Can set_authority be called with the zero address as new_authority, permanently locking the whitelist? (Critical)",
  "[File: idl/whitelist.json] [Edge Case] [Program Upgrade] If the whitelist program is upgraded, can existing whitelist_state and resolver_access accounts become incompatible, breaking authorization? (High)",
  "[File: idl/whitelist.json] [Edge Case] [Account Close Race] Can resolver_access be closed via deregister while fusion-swap is reading it for authorization, causing transaction failures\n\n### Citations\n\n**File:** idl/whitelist.json (L1-371)\n```json\n{",
  "[File: idl/whitelist.json] [Function: initialize] [Reinitialization Attack] Can an attacker call initialize() multiple times if the whitelist_state PDA already exists, potentially overwriting the authority and taking control of the whitelist system? (Critical)",
  "[File: idl/whitelist.json] [Function: initialize] [Authority Hijacking] Does the initialize instruction properly validate that whitelist_state hasn't been initialized before, or can an attacker front-run the legitimate initialization to set themselves as the authority? (Critical)",
  "[File: idl/whitelist.json] [Function: initialize] [PDA Collision] Can an attacker exploit the deterministic PDA derivation of whitelist_state (seeds: 'whitelist_state') to predict the account address and pre-fund it with malicious data before initialization? (High)",
  "[File: idl/whitelist.json] [Function: initialize] [Missing Rent Exemption Check] Does the initialize instruction ensure the whitelist_state account is rent-exempt, or can an attacker cause the account to be reclaimed by creating it with insufficient lamports? (Medium)",
  "[File: idl/whitelist.json] [Function: initialize] [Account Size Validation] Can an attacker manipulate the account creation to allocate insufficient space for WhitelistState, causing future operations to fail or corrupt state? (Medium)",
  "[File: idl/whitelist.json] [Function: initialize] [System Program Validation] Is the system_program address (11111111111111111111111111111111) hardcoded correctly, or can an attacker substitute a malicious program during initialization? (High)",
  "[File: idl/whitelist.json] [Function: initialize] [Authority Persistence] After initialization, is the authority field in WhitelistState immutable except through set_authority, or can it be modified through unintended paths? (High)",
  "[File: idl/whitelist.json] [Function: initialize] [Discriminator Collision] Can an attacker create an account with the same discriminator [175, 175, 109, 31, 13, 152, 155, 237] to impersonate a legitimately initialized whitelist_state? (High)",
  "[File: idl/whitelist.json] [Function: initialize] [Concurrent Initialization] If multiple transactions attempt to initialize the whitelist simultaneously, can this lead to race conditions or undefined state? (Medium)",
  "[File: idl/whitelist.json] [Function: initialize] [Missing Signer Validation] Does the instruction properly verify that the authority account is a signer, or can an unsigned account be passed as authority? (Critical)",
  "[File: idl/whitelist.json] [Function: register] [Unauthorized Registration] Can a non-authority user call register() by providing their own public key as the authority parameter, bypassing access control and adding themselves to the whitelist? (Critical)",
  "[File: idl/whitelist.json] [Function: register] [Authority Validation Bypass] Does register properly verify that the authority signer matches the authority stored in whitelist_state, or can an attacker sign with any account and register arbitrary resolvers? (Critical)",
  "[File: idl/whitelist.json] [Function: register] [PDA Collision Attack] Can an attacker manipulate the _user parameter to create a resolver_access PDA that collides with an existing account, potentially corrupting state or enabling unauthorized access? (High)",
  "[File: idl/whitelist.json] [Function: register] [Duplicate Registration] Can an attacker call register() multiple times for the same user to create duplicate resolver_access PDAs, causing state inconsistency or resource exhaustion? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Resolver Access Overwrite] If resolver_access PDA already exists for a user, does register fail properly, or can it overwrite existing access data including the bump seed? (High)",
  "[File: idl/whitelist.json] [Function: register] [Bump Seed Manipulation] Can an attacker exploit the bump field in ResolverAccess (u8) by providing a crafted user pubkey that generates a predictable bump, enabling PDA prediction attacks? (High)",
  "[File: idl/whitelist.json] [Function: register] [Cross-Program Invocation] When register creates the resolver_access PDA, can a malicious program intercept the CPI to the system program and substitute malicious account data? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Account Ownership Validation] Does register verify that the created resolver_access account is owned by the whitelist program, or can an attacker provide a pre-existing account owned by another program? (High)",
  "[File: idl/whitelist.json] [Function: register] [Self-Registration] Can the authority register themselves as a resolver, and if so, does this create a conflict of interest or enable privilege escalation attacks? (Low)",
  "[File: idl/whitelist.json] [Function: register] [Seed Injection Attack] Can an attacker craft a user pubkey that, when combined with the 'resolver_access' seed, produces a PDA that collides with critical protocol accounts? (High)",
  "[File: idl/whitelist.json] [Function: register] [Whitelist State Validation] Does register properly validate that whitelist_state is initialized before allowing registration, or can it be called with an uninitialized state account? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Discriminator Verification] Can an attacker provide a fake whitelist_state account with the correct discriminator [246, 118, 44, 60, 71, 37, 201, 55] but malicious authority data? (High)",
  "[File: idl/whitelist.json] [Function: register] [Rent Exemption] Does register ensure resolver_access is created with sufficient lamports for rent exemption, or can the account be reclaimed causing resolver access loss? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Authority Lamport Drain] Since authority is marked writable, can an attacker exploit register to drain lamports from the authority account through excessive registrations? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Zero Address Registration] Can an attacker register the zero address (11111111111111111111111111111111) or other system accounts as resolvers, causing undefined behavior? (High)",
  "[File: idl/whitelist.json] [Function: register] [Program ID Registration] Can an attacker register program IDs as resolvers, enabling cross-program attacks or CPI exploits in the fusion-swap program? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Batch Registration DoS] Can an attacker force the authority to register thousands of fake resolvers, exhausting compute units or storage to DoS legitimate resolver operations? (Medium)",
  "[File: idl/whitelist.json] [Function: register] [Missing Initialization Check] Does register verify that resolver_access doesn't already exist, or can it be called repeatedly causing account reinitialization vulnerabilities? (High)",
  "[File: idl/whitelist.json] [Function: register] [Account Size Exploitation] Can an attacker manipulate account size during resolver_access creation to allocate excessive space, draining authority lamports through rent requirements? (Low)",
  "[File: idl/whitelist.json] [Function: register] [PDA Bump Exhaustion] If the bump seed derivation fails for a specific user pubkey, does register handle this gracefully, or can it cause transaction failures exploitable for DoS? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [Unauthorized Deregistration] Can a non-authority user call deregister() to remove legitimate resolvers from the whitelist, disrupting protocol operations and causing resolver access loss? (Critical)",
  "[File: idl/whitelist.json] [Function: deregister] [Authority Bypass] Does deregister properly validate that the signer matches the authority in whitelist_state, or can any user deregister any resolver by forging the authority signature? (Critical)",
  "[File: idl/whitelist.json] [Function: deregister] [Self-Deregistration Prevention] Can the authority accidentally or maliciously deregister themselves if they are also a resolver, locking themselves out of management functions? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [Resolver Access Deletion] When deregister closes the resolver_access account, are lamports properly returned to the authority, or can they be stolen by providing a malicious destination account? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [PDA Validation] Does deregister verify that the resolver_access account is derived from the correct seeds ('resolver_access' + user), or can an attacker provide a fake PDA? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Non-Existent Resolver] Can an attacker call deregister with a user that was never registered, potentially causing undefined behavior or transaction failures exploitable for DoS? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [Double Deregistration] Can deregister be called multiple times for the same user after the resolver_access account is closed, enabling lamport theft or state corruption? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Account Ownership Check] Does deregister verify that resolver_access is owned by the whitelist program before closing, or can it close accounts owned by other programs? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Discriminator Validation] Does deregister check that resolver_access has the correct discriminator [32, 2, 74, 248, 174, 108, 70, 156], or can an attacker provide any account with the correct PDA derivation? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Lamport Destination] When resolver_access is closed, does the instruction hardcode the lamport recipient as authority, or can an attacker redirect funds to an arbitrary account? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Concurrent Deregistration] If multiple deregister transactions target the same resolver simultaneously, can this cause race conditions or double-spending of lamports? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Active Order Check] Does deregister verify that the resolver has no active orders in fusion-swap before removal, or can deregistration strand orders mid-execution? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Whitelist State Validation] Does deregister properly validate that whitelist_state is initialized and matches the expected PDA, or can it operate on a fake state account? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Authority Writable Exploit] Since authority is marked writable, can an attacker exploit deregister to modify authority account state beyond intended lamport returns? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Resolver Access Writable] Since resolver_access is marked writable, can an attacker exploit this to corrupt the account data before it's closed, affecting other protocol operations? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [System Program Substitution] Can an attacker provide a fake system program address instead of 11111111111111111111111111111111 to prevent proper account closure? (High)",
  "[File: idl/whitelist.json] [Function: deregister] [Bump Validation] Does deregister verify that the bump field in resolver_access matches the expected bump from PDA derivation, or can an attacker provide an account with an incorrect bump? (Medium)",
  "[File: idl/whitelist.json] [Function: deregister] [Account Data Residue] After resolver_access is closed, does any data remain accessible that could leak sensitive information or enable reinitialization attacks? (Low)",
  "[File: idl/whitelist.json] [Function: deregister] [Griefing Attack] Can a malicious authority repeatedly register and deregister resolvers to cause gas exhaustion or disrupt resolver operations through state churn? (Low)",
  "[File: idl/whitelist.json] [Function: set_authority] [Authority Validation Bypass] Does set_authority properly verify that current_authority matches the authority stored in whitelist_state, or can any user become the new authority? (Critical)",
  "[File: idl/whitelist.json] [Function: set_authority] [Permanent Authority Loss] If set_authority sets new_authority to an uncontrolled address (e.g., zero address, burn address), does it validate against this, or can the whitelist become permanently unmanageable? (Critical)",
  "[File: idl/whitelist.json] [Function: set_authority] [Front-Running Attack] Can an attacker monitor the mempool for set_authority transactions and front-run them to set themselves as the new authority before the legitimate transaction executes? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Authority Rotation DoS] Can the current authority repeatedly call set_authority in rapid succession, causing compute unit exhaustion or preventing other whitelist operations? (Low)",
  "[File: idl/whitelist.json] [Function: set_authority] [New Authority Validation] Does set_authority validate that new_authority is a valid public key and not a system program or invalid address? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [Whitelist State Corruption] Since whitelist_state is marked writable, can set_authority accidentally corrupt other state fields beyond the authority field during the update? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [PDA Validation] Does set_authority verify that whitelist_state is derived from the correct seed ('whitelist_state'), or can an attacker provide a fake state account? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Discriminator Check] Does set_authority validate that whitelist_state has the correct discriminator [246, 118, 44, 60, 71, 37, 201, 55], or can it operate on accounts with forged discriminators? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Atomic Authority Transfer] If set_authority fails mid-execution, can it leave the whitelist in a state where no authority is set, permanently bricking the protocol? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Same Authority Assignment] Can current_authority set new_authority to themselves, and if so, does this create unnecessary state writes or expose transaction replay vulnerabilities? (Low)",
  "[File: idl/whitelist.json] [Function: set_authority] [Authority Signer Validation] Is current_authority properly validated as a signer, or can an unsigned account be passed, enabling authority changes without proper authentication? (Critical)",
  "[File: idl/whitelist.json] [Function: set_authority] [Whitelist State Ownership] Does set_authority verify that whitelist_state is owned by the whitelist program, or can it modify accounts owned by malicious programs? (High)",
  "[File: idl/whitelist.json] [Function: set_authority] [Account Writable Exploit] Since current_authority is marked writable, can an attacker exploit set_authority to drain lamports from the current authority account? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [Multiple Authority Transitions] Can an attacker chain multiple set_authority calls in a single transaction to perform complex authority manipulation attacks? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [New Authority Collision] Can an attacker set new_authority to an address that collides with existing resolver_access PDAs, causing authorization conflicts? (Low)",
  "[File: idl/whitelist.json] [Function: set_authority] [Event Emission] If set_authority doesn't emit an event, can authority changes go unnoticed, enabling stealth takeover attacks without off-chain detection? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [Reentrancy Guard] Can set_authority be called recursively through CPI, enabling reentrancy attacks that manipulate authority state mid-execution? (Medium)",
  "[File: idl/whitelist.json] [Function: set_authority] [State Initialization Check] Does set_authority verify that whitelist_state is initialized before allowing authority changes, or can it operate on uninitialized state? (Medium)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Authority Immutability] Can the authority field in WhitelistState be modified through memory manipulation or buffer overflow attacks, bypassing set_authority validation? (Critical)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Discriminator Forgery] Can an attacker create a fake account with discriminator [246, 118, 44, 60, 71, 37, 201, 55] that passes validation but contains malicious authority data? (High)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Struct Size] Is WhitelistState allocated with exactly 32 bytes for the authority pubkey, or can size mismatches cause deserialization errors or buffer overflows? (Medium)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Authority Zero Check] Does WhitelistState validate that authority is not the zero pubkey during initialization or updates, preventing permanent protocol lockout? (High)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [PDA Bump Storage] Should WhitelistState also store its own bump seed for verification, or does the absence of this field enable PDA collision attacks? (Medium)",
  "[File: idl/whitelist.json] [Account: WhitelistState] [Account Closure] Can WhitelistState be closed through system program calls, permanently destroying the whitelist and disabling all resolver access control? (Critical)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Bump Seed Range] Is the bump field in ResolverAccess properly constrained to valid bump values (0-255), or can it be set to invalid values causing PDA derivation failures? (Medium)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Discriminator Collision] Can an attacker create accounts with discriminator [32, 2, 74, 248, 174, 108, 70, 156] that pass as legitimate resolver_access accounts? (High)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Struct Minimal Data] Does ResolverAccess containing only a bump field (u8) provide sufficient information, or should it include additional metadata like registration timestamp or resolver status? (Low)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Memory Alignment] Can the single u8 bump field cause memory alignment issues or padding exploits during serialization/deserialization? (Low)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Account Reuse] After deregistration, can the resolver_access account address be reused for a different resolver, causing authorization confusion? (Medium)",
  "[File: idl/whitelist.json] [Account: ResolverAccess] [Bump Modification] Can the bump field be modified after ResolverAccess creation, enabling attackers to manipulate PDA verification in fusion-swap operations? (High)",
  "[File: idl/whitelist.json] [PDA: whitelist_state] [Seed Collision] Can an attacker find alternative seed combinations that produce the same PDA as 'whitelist_state', enabling impersonation attacks? (High)",
  "[File: idl/whitelist.json] [PDA: whitelist_state] [Seed Hardcoding] Are the seed bytes [119, 104, 105, 116, 101, 108, 105, 115, 116, 95, 115, 116, 97, 116, 101] correctly encoding 'whitelist_state', or is there an encoding mismatch? (Medium)",
  "[File: idl/whitelist.json] [PDA: whitelist_state] [Canonical Bump] Does the protocol use the canonical bump (255 -> 0 search) for whitelist_state derivation, or can non-canonical bumps cause validation bypasses? (Medium)",
  "[File: idl/whitelist.json] [PDA: whitelist_state] [Cross-Program PDA] Can another program derive the same whitelist_state PDA and create it first, hijacking the whitelist initialization? (High)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [User Pubkey Manipulation] Can an attacker craft specific user pubkeys that, when combined with 'resolver_access' seed, produce PDAs that collide with critical system accounts? (High)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Seed Order] Are the seeds for resolver_access correctly ordered as ['resolver_access', user], or can seed order manipulation enable PDA prediction attacks? (Medium)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Bump Exhaustion] Can an attacker provide a user pubkey where no valid bump exists (0-255 exhausted), causing DoS for that specific resolver registration? (Low)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Seed Length] Are the seed bytes [114, 101, 115, 111, 108, 118, 101, 114, 95, 97, 99, 99, 101, 115, 115] correctly encoding 'resolver_access', or is there truncation/padding? (Medium)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Multi-Program Collision] Can resolver_access PDAs derived by the whitelist program collide with PDAs from other programs (like fusion-swap), causing authorization conflicts? (Medium)",
  "[File: idl/whitelist.json] [PDA: resolver_access] [Canonical Bump Validation] Does the protocol verify that the stored bump in ResolverAccess matches the canonical bump from derivation, preventing bump manipulation attacks? (High)",
  "[File: idl/whitelist.json] [CPI Security] [Fusion-Swap Integration] When fusion-swap calls whitelist through CPI to validate resolver access, can an attacker provide a fake whitelist program address to bypass authorization? (Critical)",
  "[File: idl/whitelist.json] [CPI Security] [Account Passing] Can fusion-swap pass incorrect resolver_access accounts to whitelist CPI calls, enabling unauthorized resolvers to fill orders? (Critical)",
  "[File: idl/whitelist.json] [CPI Security] [PDA Verification] Does the whitelist program verify that CPIs are coming from the legitimate fusion-swap program, or can malicious programs call whitelist functions? (High)",
  "[File: idl/whitelist.json] [CPI Security] [Reentrancy Attacks] Can a malicious program call whitelist instructions through CPI in a recursive manner, causing state corruption or compute unit exhaustion? (Medium)",
  "[File: idl/whitelist.json] [CPI Security] [System Program CPI] When whitelist instructions invoke the system program to create/close accounts, can an attacker intercept or manipulate these CPIs? (High)",
  "[File: idl/whitelist.json] [CPI Security] [Account Ownership Transfer] Can CPIs to whitelist change account ownership in unexpected ways, enabling account hijacking or state corruption? (High)",
  "[File: idl/whitelist.json] [CPI Security] [Instruction Discrimination] Does whitelist properly discriminate between direct calls and CPI calls, applying appropriate validation for each context? (Medium)",
  "[File: idl/whitelist.json] [CPI Security] [Program ID Validation] Does whitelist validate that the invoking program is authorized (e.g., fusion-swap), or can any program call whitelist instructions through CPI? (High)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Error Code Collision] Can error code 6000 (Unauthorized) collide with error codes from other programs, causing confusion in error handling or client applications? (Low)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Generic Error] Is the single 'Unauthorized' error sufficient, or should whitelist define more specific errors (e.g., InvalidAuthority, ResolverNotFound, AlreadyRegistered) for better debugging? (Low)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Error Propagation] When whitelist returns Unauthorized through CPI to fusion-swap, can this error be properly caught and handled, or does it cause transaction failures? (Medium)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Missing Errors] Are there missing error definitions for critical failure cases like DoubleInitialization, InvalidPDA, or AccountClosureFailed that could obscure security vulnerabilities? (Medium)",
  "[File: idl/whitelist.json] [Error: Unauthorized] [Error Message Leakage] Does the 'Unauthorized' error message leak sensitive information about whitelist state or authority addresses that could aid attackers? (Low)",
  "[File: idl/whitelist.json] [Discriminator: initialize] [Instruction Collision] Can the initialize discriminator [175, 175, 109, 31, 13, 152, 155, 237] collide with discriminators from other programs, causing unintended instruction execution? (High)",
  "[File: idl/whitelist.json] [Discriminator: register] [Discriminator Prediction] Can an attacker predict the register discriminator [211, 124, 67, 15, 211, 194, 178, 240] and craft malicious transactions that execute register with forged parameters? (Medium)",
  "[File: idl/whitelist.json] [Discriminator: deregister] [Instruction Spoofing] Can an attacker craft a transaction with the deregister discriminator [161, 178, 39, 189, 231, 224, 13, 187] that bypasses validation by appearing legitimate? (Medium)",
  "[File: idl/whitelist.json] [Discriminator: set_authority] [Discriminator Brute Force] Can an attacker brute-force instruction discriminators to find collisions with set_authority [133, 250, 37, 21, 110, 163, 26, 121], enabling unauthorized authority changes? (High)",
  "[File: idl/whitelist.json] [Discriminator: WhitelistState] [Account Type Confusion] Can an attacker create an account with WhitelistState discriminator [246, 118, 44, 60, 71, 37, 201, 55] that passes type checks but contains invalid data? (High)",
  "[File: idl/whitelist.json] [Discriminator: ResolverAccess] [Account Impersonation] Can an attacker create fake resolver_access accounts with discriminator [32, 2, 74, 248, 174, 108, 70, 156] to impersonate whitelisted resolvers? (Critical)",
  "[File: idl/whitelist.json] [Account Validation] [Authority Signer Check] Across all instructions, is the authority/current_authority account properly validated as a signer, or can unsigned accounts be passed? (Critical)",
  "[File: idl/whitelist.json] [Account Validation] [PDA Derivation Verification] Do all instructions that use PDAs (whitelist_state, resolver_access) verify the PDA is derived with correct seeds and bump, or can fake accounts be provided? (Critical)",
  "[File: idl/whitelist.json] [Account Validation] [Account Ownership] Do instructions validate that whitelist_state and resolver_access are owned by the whitelist program (5jzZhrzqkbdwp5d3J1XbmaXMRnqeXimM1mDMoGHyvR7S)? (High)",
  "[File: idl/whitelist.json] [Account Validation] [Writable Account Abuse] For accounts marked writable (authority, whitelist_state, resolver_access), can attackers exploit write permissions to corrupt data or drain lamports? (High)",
  "[File: idl/whitelist.json] [Account Validation] [System Program Validation] Is the system_program address (11111111111111111111111111111111) validated as the actual system program, or can a fake program be substituted? (High)",
  "[File: idl/whitelist.json] [Account Validation] [Account Initialization State] Do instructions check whether accounts are initialized before operating on them, preventing operations on uninitialized accounts? (High)",
  "[File: idl/whitelist.json] [Account Validation] [Account Size Verification] Do instructions verify that account sizes match expected sizes for WhitelistState and ResolverAccess, preventing buffer overflow or underflow? (Medium)",
  "[File: idl/whitelist.json] [Account Validation] [Account Discriminator Check] Do all instructions validate account discriminators before deserializing, preventing type confusion attacks? (High)",
  "[File: idl/whitelist.json] [State Transition] [Initialization -> Registration] Can register be called before initialize completes, causing undefined behavior or allowing registration without proper authority setup? (High)",
  "[File: idl/whitelist.json] [State Transition] [Registration -> Deregistration] Can a resolver be deregistered while they have active orders in fusion-swap, stranding tokens in escrow? (Medium)",
  "[File: idl/whitelist.json] [State Transition] [Authority Change -> Operations] After set_authority is called, are there race conditions where the old authority can still perform operations before state updates propagate? (Medium)",
  "[File: idl/whitelist.json] [State Transition] [Deregistration -> Re-registration] Can a deregistered resolver be immediately re-registered with the same user pubkey, and does this create security risks or state inconsistency? (Low)",
  "[File: idl/whitelist.json] [State Transition] [Concurrent Operations] If multiple instructions (register, deregister, set_authority) execute concurrently, can this cause race conditions or state corruption? (Medium)",
  "[File: idl/whitelist.json] [State Transition] [Atomic State Updates] Are state updates in whitelist_state and resolver_access atomic, or can partial updates occur during transaction failures? (High)",
  "[File: idl/whitelist.json] [Economic Attack] [Registration Cost] Does register require the authority to pay rent for resolver_access accounts, and can this be exploited to drain authority funds through mass registrations? (Medium)",
  "[File: idl/whitelist.json] [Economic Attack] [Deregistration Refund] When resolver_access is closed via deregister, are refunded lamports properly credited, or can they be stolen through refund manipulation? (High)",
  "[File: idl/whitelist.json] [Economic Attack] [Whitelist Griefing] Can an attacker force the authority to waste compute units by repeatedly triggering failed register/deregister operations? (Low)",
  "[File: idl/whitelist.json] [Economic Attack] [Resolver Bribery] Can resolvers bribe the authority to get registered, and does the whitelist design prevent such off-chain corruption? (Low)",
  "[File: idl/whitelist.json] [Fusion Integration] [Resolver Validation Bypass] When fusion-swap checks resolver authorization, can it bypass whitelist validation by directly checking resolver_access PDA existence without CPI? (Critical)",
  "[File: idl/whitelist.json] [Fusion Integration] [Account Passing] Can fusion-swap pass fake resolver_access accounts that aren't actually whitelisted but have the correct PDA structure? (Critical)",
  "[File: idl/whitelist.json] [Fusion Integration] [Authorization Timing] Is there a time gap between resolver registration and when they can fill orders, allowing unauthorized fills during registration? (Medium)",
  "[File: idl/whitelist.json] [Fusion Integration] [Resolver Revocation] If a resolver is deregistered mid-order-fill in fusion-swap, can this cause the fill transaction to fail, locking tokens in escrow? (Medium)",
  "[File: idl/whitelist.json] [Fusion Integration] [Cross-Program State] Can inconsistencies between whitelist state and fusion-swap state (e.g., resolver registered in whitelist but not active in fusion-swap) create exploits? (Medium)",
  "[File: idl/whitelist.json] [DoS] [Compute Unit Exhaustion] Can an attacker craft instructions with maximum account list lengths or complex PDA derivations to exhaust compute units and DoS the whitelist? (Medium)",
  "[File: idl/whitelist.json] [DoS] [Account Spam] Can an attacker register thousands of resolvers to spam resolver_access accounts, exhausting storage and making legitimate operations expensive? (Medium)",
  "[File: idl/whitelist.json] [DoS] [Transaction Flooding] Can an attacker flood the network with whitelist transactions to prevent legitimate registrations or authority changes? (Low)",
  "[File: idl/whitelist.json] [DoS] [PDA Derivation DoS] Can an attacker provide user pubkeys that require maximum iterations to find a valid bump, causing compute unit exhaustion during register? (Low)",
  "[File: idl/whitelist.json] [DoS] [Account Lock] Can an attacker lock critical accounts (whitelist_state, resolver_access) by creating long-running transactions that hold account write locks? (Low)",
  "[File: idl/whitelist.json] [Missing Feature] [Resolver Listing] Does the whitelist provide a way to query all registered resolvers, or can unauthorized resolvers claim to be whitelisted without verification? (Medium)",
  "[File: idl/whitelist.json] [Missing Feature] [Registration Timestamp] Does ResolverAccess store when a resolver was registered, and without this, can historical authorization disputes arise? (Low)",
  "[File: idl/whitelist.json] [Missing Feature] [Resolver Metadata] Should ResolverAccess include metadata like resolver name, status, or reputation score, and does the absence of this create security gaps? (Low)",
  "[File: idl/whitelist.json] [Missing Feature] [Temporary Suspension] Does the whitelist support temporarily suspending resolvers without full deregistration, and without this, can misbehaving resolvers continue operations? (Medium)",
  "[File: idl/whitelist.json] [Missing Feature] [Multi-Signature Authority] Does the whitelist support multi-sig authority, or is a single authority pubkey a single point of failure? (High)",
  "[File: idl/whitelist.json] [Missing Feature] [Authority Recovery] If the authority private key is lost, is there a recovery mechanism, or does the whitelist become permanently unmanageable? (High)",
  "[File: idl/whitelist.json] [Missing Feature] [Event Emission] Does the whitelist emit events for register, deregister, and set_authority operations, and without events, can off-chain systems track state changes? (Medium)",
  "[File: idl/whitelist.json] [Missing Feature] [Resolver Count] Does WhitelistState track the total number of registered resolvers, and without this, can resolver limits be enforced? (Low)",
  "[File: idl/whitelist.json] [Edge Case] [Empty Whitelist] Can fusion-swap operate when no resolvers are registered, and does this create a DoS vector if the authority deregisters all resolvers? (Medium)",
  "[File: idl/whitelist.json] [Edge Case] [Authority Change During Operations] If set_authority is called while resolvers are actively filling orders, can this cause authorization failures mid-transaction? (Medium)",
  "[File: idl/whitelist.json] [Edge Case] [Maximum Resolvers] Is there a limit on the number of resolvers that can be registered, and without limits, can storage exhaustion DoS the protocol? (Medium)",
  "[File: idl/whitelist.json] [Edge Case] [Zero Authority] Can set_authority be called with the zero address as new_authority, permanently locking the whitelist? (Critical)",
  "[File: idl/whitelist.json] [Edge Case] [Program Upgrade] If the whitelist program is upgraded, can existing whitelist_state and resolver_access accounts become incompatible, breaking authorization? (High)",
  "[File: idl/whitelist.json] [Edge Case] [Account Close Race] Can resolver_access be closed via deregister while fusion-swap is reading it for authorization, causing transaction failures\n\n### Citations\n\n**File:** idl/whitelist.json (L1-371)\n```json\n{",
  "[File: package.json] [Dependencies: @coral-xyz/anchor@^0.31.1] [Supply chain attack] Could a compromised version of the Anchor framework (using caret versioning) introduce malicious code that manipulates program deployments or injects backdoors into compiled programs, potentially enabling unauthorized token transfers? (Critical)",
  "[File: package.json] [Dependencies: @solana/spl-token@^0.4.9] [Supply chain attack] Does the caret versioning (^0.4.9) for spl-token allow automatic updates to minor/patch versions that could contain compromised token transfer logic, leading to potential token theft during program execution? (Critical)",
  "[File: package.json] [Dependencies: tweetnacl@^1.0.3] [Cryptographic backdoor] Could a malicious update to the tweetnacl cryptography library (via caret versioning) weaken signature validation or key generation, compromising resolver authentication or transaction signing? (Critical)",
  "[File: package.json] [Dependencies: borsh@^2.0.0] [Deserialization attack] Could a compromised borsh serialization library introduce deserialization vulnerabilities that allow attackers to craft malicious account data, corrupting program state during order creation or filling? (High)",
  "[File: package.json] [Dependencies: @noble/hashes@^1.7.1] [Hash collision] Could a backdoored version of @noble/hashes allow hash collisions in PDA derivation, enabling attackers to generate colliding escrow addresses and steal tokens from multiple orders? (Critical)",
  "[File: package.json] [Dependencies: anchor-bankrun@^0.5.0] [Test manipulation] Could a compromised test framework hide vulnerabilities during testing by manipulating test results, allowing critical bugs to pass into production deployments? (High)",
  "[File: package.json] [Dependencies: solana-bankrun@^0.4.0] [Sandbox escape] Could vulnerabilities in the bankrun testing environment allow test code to escape the sandbox and access production keys or wallets during development? (Medium)",
  "[File: package.json] [Dependencies: spl-token-bankrun@^0.2.6] [Mock bypass] Could the token bankrun mock be bypassed or manipulated to create false positive test results that hide real token transfer vulnerabilities? (Medium)",
  "[File: package.json] [Dependencies: prompt-sync@^4.2.0] [Input injection] Could the prompt-sync library be vulnerable to input injection attacks during interactive script execution, potentially leaking private keys or sensitive configuration? (Medium)",
  "[File: package.json] [DevDependencies: @solana-developers/helpers@^2.7.0] [Development backdoor] Could compromised developer helper utilities inject malicious code during development that gets included in production builds? (High)",
  "[File: package.json] [DevDependencies: bs58@^6.0.0] [Encoding manipulation] Could a backdoored bs58 library manipulate base58 encoding/decoding during key or address handling, redirecting funds to attacker-controlled addresses? (Critical)",
  "[File: package.json] [DevDependencies: keccak@^3.0.4] [Hash manipulation] Could a compromised keccak library weaken hash operations used in PDA seed generation, enabling PDA collision attacks? (High)",
  "[File: package.json] [Script: build:all] [Build injection] Could the 'cargo build-sbf && anchor build -p fusion-swap && anchor build -p whitelist' command sequence be exploited via environment variable injection to inject malicious code into compiled programs? (Critical)",
  "[File: package.json] [Script: build] [Program substitution] Could an attacker with access to the build environment replace the anchor build output with a malicious program binary that steals tokens during deployment? (Critical)",
  "[File: package.json] [Script: deploy:fusion_swap] [Deployment hijacking] Does the incomplete deploy command ('--provider.cluster ') allow command injection or cluster redirection, potentially deploying programs to attacker-controlled endpoints? (High)",
  "[File: package.json] [Script: deploy:whitelist] [Access control bypass] Could the deploy script be manipulated to deploy a compromised whitelist program that grants unauthorized resolver access, bypassing protocol access controls? (Critical)",
  "[File: package.json] [Script: clean] [State deletion] Could malicious execution of 'anchor clean' during active operations corrupt program state or delete critical build artifacts needed for security verification? (Medium)",
  "[File: package.json] [Script: sync] [Key manipulation] Could the 'anchor keys sync' command be exploited to sync incorrect program IDs, causing client scripts to interact with malicious program deployments? (High)",
  "[File: package.json] [Script: test:all] [Test bypass] Could the 'RUST_LOG=error' environment variable suppress critical security warnings during testing, hiding vulnerabilities before production deployment? (Medium)",
  "[File: package.json] [Script: test] [Incomplete validation] Does running 'anchor test' without the full test:all suite skip important cargo tests that could catch critical security bugs in Rust logic? (High)",
  "[File: package.json] [Script: debug] [Information leakage] Could the 'DEBUG=1' environment variable expose sensitive program internals, private keys, or transaction details in log output during debugging? (Medium)",
  "[File: package.json] [Script: lint:rust:fix] [Auto-fix manipulation] Could 'cargo clippy --fix --allow-dirty --allow-staged' automatically introduce malicious code changes disguised as lint fixes, modifying critical security checks? (High)",
  "[File: package.json] [Script: lint:ts:fix] [Prettier manipulation] Could the prettier configuration be exploited to inject malicious code during auto-formatting of TypeScript files, particularly in script files that handle token transfers? (Medium)",
  "[File: package.json] [Script: lint:fix] [Chained exploit] Could running 'yarn lint:fix' execute both TypeScript and Rust fixes in sequence, amplifying injection risks across both codebases? (Medium)",
  "[File: package.json] [All scripts] [Yarn exploit] Could vulnerabilities in the yarn package manager itself be exploited to hijack script execution, redirecting to malicious commands during any script invocation? (High)",
  "[File: package.json] [Dependencies: Caret versioning (^)] [Uncontrolled updates] Do all dependencies use caret versioning, allowing automatic minor/patch updates that could introduce breaking changes or security vulnerabilities without explicit approval? (High)",
  "[File: package.json] [Dependencies: @coral-xyz/anchor@^0.31.1] [Breaking changes] Could automatic updates from 0.31.1 to 0.31.x introduce breaking changes in program instruction handling, causing transaction failures or fund locks? (Medium)",
  "[File: package.json] [Dependencies: typescript@^5.7.3] [Type safety bypass] Could TypeScript compiler updates change type checking behavior, allowing previously caught type errors to pass, potentially leading to runtime bugs in critical operations? (Medium)",
  "[File: package.json] [Dependencies] [Missing lock file verification] Are dependency lock files (yarn.lock/package-lock.json) properly verified and committed, or could CI/CD fetch different versions than intended during deployment builds? (High)",
  "[File: package.json] [Script: deploy:fusion_swap] [Incomplete cluster specification] Does the incomplete '--provider.cluster ' flag mean the deployment script accepts cluster input at runtime, potentially allowing accidental mainnet deployments during testing? (High)",
  "[File: package.json] [Script: deploy:whitelist] [Deployment order] If whitelist is deployed after fusion_swap, could there be a window where fusion_swap operates without access controls, allowing unauthorized order fills? (Critical)",
  "[File: package.json] [Script: deploy commands] [Key exposure] Do the deployment scripts require private keys to be passed as environment variables or command-line arguments, potentially exposing them in shell history or process listings? (High)",
  "[File: package.json] [Script: deploy commands] [No verification] Do the deployment scripts lack post-deployment verification, potentially deploying corrupted programs without detecting issues until user funds are at risk? (High)",
  "[File: package.json] [Script: build:all] [Non-deterministic builds] Could the build process produce different program binaries on different machines due to non-deterministic compilation, making it impossible to verify deployed program integrity? (Medium)",
  "[File: package.json] [Dependencies: All] [Floating versions] Do caret versions prevent reproducible builds, making it impossible to verify that production deployments match audited code? (High)",
  "[File: package.json] [License: MIT] [Dependency license conflicts] Could transitive dependencies have incompatible licenses (e.g., GPL) that create legal risks or indicate potentially malicious packages? (Low)",
  "[File: package.json] [Script: test:all] [Test ordering] Does running 'anchor test --skip-build && cargo test' in sequence mean that Anchor tests run on stale builds, potentially missing recently introduced bugs? (Medium)",
  "[File: package.json] [Script: test] [Incomplete coverage] Does running only 'anchor test' without cargo tests skip unit tests for critical Rust logic like auction calculations or PDA derivations? (High)",
  "[File: package.json] [Script: test:all with RUST_LOG=error] [Warning suppression] Could setting RUST_LOG=error hide important security warnings or panics during test execution, allowing vulnerabilities to pass unnoticed? (Medium)",
  "[File: package.json] [DevDependencies: mocha/chai] [Test framework exploits] Could vulnerabilities in the test framework itself be exploited to manipulate test results, hiding security bugs during audits? (Medium)",
  "[File: package.json] [DevDependencies: ts-mocha@^10.0.0] [TypeScript test bypass] Could the ts-mocha runner fail to properly type-check test files, allowing type-unsafe test code that doesn't catch real program bugs? (Low)",
  "[File: package.json] [Script: typecheck] [Incomplete checking] Does 'tsc --noEmit --skipLibCheck' skip checking of library types, potentially missing type mismatches in critical Anchor or Solana SDK interactions? (Medium)",
  "[File: package.json] [DevDependencies: @types/*] [Type definition manipulation] Could compromised type definition packages provide incorrect types for Solana/Anchor APIs, causing developers to misuse security-critical functions? (Medium)",
  "[File: package.json] [Scripts: All] [CI environment injection] Could environment variables in CI/CD pipelines be manipulated to inject malicious commands during script execution, compromising build artifacts? (High)",
  "[File: package.json] [Scripts: build/deploy] [Artifact tampering] Are build artifacts cryptographically signed and verified before deployment, or could an attacker replace compiled programs between build and deploy steps? (High)",
  "[File: package.json] [Scripts: deploy commands] [Automated deployment risks] If deployment scripts run in automated CI/CD, could a compromised CI environment deploy malicious programs to production without human verification? (Critical)",
  "[File: package.json] [Dependencies: Outdated versions] [Known vulnerabilities] Do any dependencies have known CVEs that could be exploited? Is there a process to monitor and update vulnerable dependencies? (High)",
  "[File: package.json] [Script: new] [Project template risks] Could 'anchor new' pull malicious project templates from compromised repositories, seeding new projects with backdoored code? (Medium)",
  "[File: package.json] [Scripts: lint:fix + build + deploy] [Attack chain] Could an attacker chain exploits across lint:fix (code injection), build (malicious compilation), and deploy (unauthorized deployment) to achieve full protocol compromise? (Critical)",
  "[File: package.json] [Scripts: clean + build] [State reset exploit] Could running 'clean' before 'build' in certain states cause the build to use cached malicious artifacts instead of clean sources? (Medium)",
  "[File: package.json] [Entire file] [File replacement] Could an attacker with repository access replace package.json with a malicious version that adds backdoored dependencies, compromising all developers who run 'yarn install'? (Critical)",
  "[File: package.json] [Entire file] [No integrity checking] Is there any mechanism to verify package.json integrity before script execution, or could local file modification go undetected? (Medium)",
  "[File: package.json] [Script: build:all with cargo build-sbf] [SBF compilation manipulation] Could the sBF (Solana Berkeley Packet Filter) compilation process be manipulated to inject malicious bytecode into the final program binary? (Critical)",
  "[File: package.json] [Dependencies: @coral-xyz/anchor@^0.31.1] [IDL manipulation] Could a compromised Anchor version generate malicious IDL files that cause client scripts to construct invalid or exploitative transactions? (High)",
  "[File: package.json] [Dependencies: @solana/spl-token@^0.4.9] [Token program interaction] Could a backdoored spl-token library manipulate token transfer instructions to redirect funds to attacker addresses during program execution? (Critical)",
  "[File: package.json] [Dependencies: prompt-sync@^4.2.0] [Interactive script risks] Could interactive prompts in deployment scripts be exploited to trick operators into authorizing malicious deployments or signing malicious transactions? (Medium)",
  "[File: package.json] [DevDependencies: prettier@^2.6.2] [Old version risks] Is prettier version 2.6.2 (from 2022) outdated and potentially containing known vulnerabilities that could be exploited during code formatting? (Low)",
  "[File: package.json] [Dependencies: All transitive dependencies] [Dependency depth attacks] Could deeply nested transitive dependencies contain malicious code that evades direct inspection, compromising the build or runtime? (High)"
]